--- 
title: Characterisation of model species interactome available from primary molecular
  interaction databases
author: "Vitalii Kleshchevnikov"
date: "21 December 2016"
output:
  pdf_document:
    citation_package: natbib
    df_print: kable
    toc: yes
  html_document: default
  word_document:
    toc: yes
documentclass: report
fontsize: 12pt
latex_engine: lualatex
mainfont: Helvetica
monofont: Helvetica
csl: Taras-Shevchenko-National-University-of-Kyiv-KNU-biology.csl
sansfont: Helvetica
bibliography: bibtex_library.bib
--- 
 
```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = FALSE, results = "hide", warning = FALSE, message = FALSE, fig.keep = "all",eval=T) 
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(UniProt.ws)
  library(PSICQUIC)
  library(ggplot2)
  library(clusterProfiler)
  library(scales)
})
  source("multiplot.R")
  source("GO_analyse_simplify_plot.R")
# library(devtools)
# install_github("vitkl/clusterProfiler")
# install_github("vitkl/DOSE")

date = Sys.Date()
## Please specify the date for which you want to perform analysis (if not today)
date = as.Date("2017-04-24")
# git update-index --assume-unchanged .RData 
# http://stackoverflow.com/questions/21043132/gitignore-just-doesnt-work-i-cant-get-it-to-ignore-ds-store-gitignore-fil

#http://rmarkdown.rstudio.com/pdf_document_format.html
#http://pandoc.org/MANUAL.html#templates
#http://anorien.csc.warwick.ac.uk/mirrors/CTAN/macros/latex/contrib/geometry/geometry.pdf
#  html_document:
#    font-family: Helvetica
#    keep_md: yes
#    toc: yes
#  word_document: default
# bibliography: bibtex_library.bib [@Peshkin2015383] 
``` 

The report was published on `r Sys.Date()`. Data used in the report was available on `r date`.

# Outline

1. Abstract
2. Introduction
3. Methods
4. Results and discussion
    - how available interactome covers the proteome
    - IntAct(IMEx) vs Biogrid
    - which proteins are missing
    - interaction detection biases
    - study bias: the more articles, the more interactions
    - which protein function are interaction databases and high-throughput datasets enriched in?
5. Conclusion  

# Abstract

The structure and the function of the cell arise from interactions between molecules inside and outside it. Investigation of those interactions is, therefore, necessary (but not sufficient) to obtain the understanding of the living systems. Gathering interaction data and depositing it in a central database for open and easy access by the research community can and does accelerate progress in the field. An attempt to unify interaction data from multiple sources meets many challenges, such as standardisation of annotation, interoperability with other resources and time it takes to manually gather the data. As new network analysis methods become available and research group start to use molecular interaction data to make inferences, generate new hypotheses and explain the results of transcriptomics and proteomics the coverage of the real interactome by our knowledge and the bias present in the databases begin to influence research results. This motivates the need to identify which proteins have no interactions are available and understand biases in our interaction data. We focus our analysis on the data deposited to the IMEx consortium of primary databases, which includes the IntAct database, the resource supported by our group.  

The best coverage we observe is for yeast, *E.coli* and human. Isoform coverage is limited, but still significant for human.  
We have investigated if IntAct database coverage is biased towards physicochemical properties of the protein and how well described the protein is in the literature. Proteins with no interactions in IntAct are on average smaller, less well-studied overall, have a lower fraction of charged residues and higher mean hydropathy.
Next, we have investigated if two high-throughput interaction detection methods (which use distinct strategies) may be biased towards physicochemical properties of the protein (such as mass): AP-MS and two-hybrid. Affinity purification followed by mass spectrometry (AP-MS) seems to capture a higher proportion of larger proteins as compared to two-hybrid methods. 
By performing enrichment analysis of the molecular function (Gene Ontology) we have found that databases and datasets which contain experimentally derived data are enriched and depleted in the same functional categories. STRING database, which includes computational prediction data, is the least biased.  
These results can inform literature curation by IMEx consortium teams and data integration efforts.  


# Introduction 
 
   The structure and the function of the cell arise from interactions between molecules inside and outside it [@Hein:2015aa]. Though proteins, nucleic acids, lipids and small molecules can all form important interactions, studies and literature focus mainly on interactions between proteins and other macromolecules. We can discover and study these molecular interactions using a number of experimental and computational techniques. This study aims to describe the coverage and the biases of currently available molecular interaction data. We focus on molecular interactions identified in the experimental setting most of which are represented (in the literature and databases) by protein-protein interactions (although, there is a considerable amount of data on protein-DNA interactions, for example, ChIP-Seq data, which is traditionally incorporated into the genomic or specialist databases). We focus on specifically on protein-protein interaction data.  
   
   Molecular interactions can be classified using multiple criteria: the information interaction detection methods can provide towards ground truth, interaction detection method, biological role of the interaction (covalent binding, enzymatic reaction, e.g.) which can be explored in molecular interaction ontology [@Hermjakob:2004aa, http://www.ebi.ac.uk/ols/ontologies/mi/]. A standard way of describing interaction allows record published interactions into databases, assign interactions a score based on the evidence and reliability and, least but not last, reuse interaction data for computational analyses, gaining insight into the novel fucntion of proteins and generate hypothesis. In the recent years, the fact that biases in molecular interaction data can mislead network-driven studies has become evident [@Schaefer:2015aa], which motivates the need to study the coverage and bias of currectly available molecular interaction data, identify missing proteins and molecular functions those protiens perform. These results may help in selecting appropriate network data for data integration studies.  
   
   We investigate the data in the IntAct database [@Orchard:2014aa] which is provider of high-depth manually curated molecular interaction data, a part of IMEx consortium. The IMEx consortium [@Orchard:2012aa] is an international collaboration between a group of major public interaction data providers who share curation effort. This study can aid literature curation effort by IntAct group by pointing to the publications contating interaction data on proteins with no interactions currently deposited in the IntAct database.  

### Defining interactome

   The aggregation of all components and their interactions into a single network results in what we call interactome, the whole of all molecular interactions. You can also look into the subset of this network, for example, you can select only those proteins that are expressed in the brain, and only the interactions between these proteins identified experimentally in the brain cells. This example reflects the complexity and the diversity of the interactome - which is what you would expect from a system underlying the complexity and the diversity of the cell types, cellular behaviours, and functions. For the same reason, only by studying these interactions and how they change in specific cell types and under specific circumstances in combination with the functional analysis we can decipher cellular regulatory networks. The ultimate goal of the research in the field would be to capture all physical interactions and thoroughly describe them while avoiding false positive results.  

### Experimental approaches for discovering interactions

![Figure 1. Association and physical associations identified using AP-MS approaches fundamentally don't provide binary interactions. Binary interactions have to be inferred from the list of proteins represented as cluster on the left. Matrix expansion links every protein to every other protein in the AP-MS-derived cluster. Spoke expansion only links the bait with all other proteins in a cluster. As you can see, none of these methods generate the exact set of binary interactions that occur in reality. Spoke expansion tends to generate less false-positives and is used more often.](./Data/expansion_methods.png)

   Numerous experimental protein interaction detection methods are currently widely used. The classification we provide is far from comprehensive but gives a short description of the methods analysed in this study. Based on the evidence provided and possibility to scale up to high-throughput studies methods can be classified into 3 main categories.  
   The first category is formed by methods using affinity purification to capture all proteins associated with the bait. Only proteins that have a direct or indirect physical connection with the bait will be purified. Following purification procedure, those proteins can be identified using western-blotting and specific antibody staining or using mass-spectrometry, latter can be done in a high-throughput manner. The main advantage of these methods is the potential ability capture any protein, in different cellular contexts and to quantitatively characterise interaction properties [@Hein:2015aa]. The main disadvantage of these techniques comes from the fact that experiments indentify both direct and indirect interactions between the bait and captured proteins and no way of distinguishing those (although, one may delete identified proteins one by one from the cell and decipher direct interactions). This type of interactions in called associations and do be represented in the network requires the use of expansion methods (Figure 1, adopted from the IntAct website). The other drawback of this method is dependency on the availability and quaility of antibodies for affinity-purification step. We will call these methods affinity-purification followed mass-spectrometry (AP-MS) across this report.  
   As defined by molecular interaction ontology [@Hermjakob:2004aa, http://www.ebi.ac.uk/ols/ontologies/mi/], an association is an interaction between molecules that may participate in formation of one, but possibly more, physical complexes, association will be called physical if experiments show enough evidence that proteins are in the same physical complex but don't show direct interaction.  
   The second category of methods is formed by protein complementation techniques which include two-hybrid (transcription factor complementation), the most widely used interaction detection method (including high-throughput experiments). In this method, pairs of proteins are tested for interaction and therefore discovered interactions are more likely to be direct (the main advantage of this method). Classic implementation of two-hybrid is performed in yeast cells and requires studied proteins to be non-membrane, however, two-hybrid for membrane proteins and for mammalian cells was also developed [@Lemmens:2015aa,@Saraon:2017aa]. The main disadvantage of two-hybrid methods is that every protein has to be cloned into a plasmid or other vector and exogenously expressed. Ability to clone protein-coding sequence and, in case of yeast two-hybrid, correct protein folding, are the limiting factors for two-hybrid but not AP-MS techniques. As a side note, the lack of antibodies for a specific bait protein may force researches to tag, clone and express protein which is a subject to similar problems, however, AP-MS would allow identification of the binding partners, no cloning needed.  
   Final category is formed by structure-based methods (co-crystallisation and X-ray crystallography, e.g.). These methods can provide valuable information on how exactly physical interaction occurs, however, these methods are extremely labor-intensive and, therefore, non-scalable and will always need complementary experiments showing if the proteins actually interact in the cellular context.  
   To conclude, all protein interaction detection methods have their strengts and weaknesses, so it is important to accept that every protein interaction detection method has it's limitations in the ability to identify true physical interaction and serves as evidence we use to infer protein interaction. By combining different methods to identify protein interaction we can gain more confidence in our findings and by disrupting interaction under specific cellular context we can identify it's function.  

### Challenges of interactomics

   Four big challenges substantially complicate the study of molecular interactions, especially on the whole organism scale. The first being that we don't know the true nature of underlying our experimental results (all assays provide evidence that interaction is possible and some can provide quantitative description, but all are prone to error and the problem described in the figure 1 A) which lead to the necessity of combining interaction data from multiple experiments and complex statistical evaluation of how probable the interaction is based on that data (such as Bayesian approach, @Braun:2009aa, @Zhang:2011aa) rather than receiving confident yes-or-no result from a single experiment. Interaction databases make an effort to score the interactions based on supporting evidence, however, this is usually done with non-probabilistic heuristic approaches, such as MI score implemented in IntAct [@Villaveces:2015aa]. Every database that aggregates interaction data from other resources will develop an algorithm to score interactions. The challenge is to identify when to put the threshold betweem high and low confidence interactions or when to say "I am confident the interaction exists".     

   The second big challenge is the problem of "noise" - or the problem of false positives. Different interaction detection experiments are prone to these errors for different reasons, for example, in-vitro experiments (e.g. TAP-MS) may allow the interaction between proteins which are normally separated between different cellular compartments. Specific groups of proteins (based on their physical or chemical properties, abundance) may have a higher susceptibility to false positives, for example, highly abundant proteins are easier to detect and may also be less efficiently diluted during the affinity purification procedure, which may lead to artifactual results. Contamination is another common problem for AP-MS experiments which have motivated the creation of contaminant database, CRAPOME [@Mellacheruvu:2013aa]. A more general problem of noise can be addressed by proteome-scale interactomics experiments (which can include enough samples to guarantee low false positive rate while still identifying interactions).  

   The third big challenge is that our knowledge of interactome is incomplete which arises from the fact that experimental approaches have low statistical power and often miss out some real interactions. Many efforts to reproduce protein interactions find little overlap between the new and the original study [@Braun:2009aa]. Also, many proteins, especially in non-model species have no know interactions.  

   The final challenge contributes to the "incomplete interactome" problem but is grounded in the fact that not all protein interaction discovered and published are included in protein interaction databases. In the other words, this is database curation problem. More than 100 public databases containing protein interactions are available now [http://pathguide.org/]. These databases differ:  
- by the types of data they include (e.g. computational prediction, manual curation experimental data from research papers (primary databases), aggregated data from many primary databases (secondary databases)),  
- the level of detail captured from articles to describe interactions  
- how often and if databases are updated with new data, identifiers and annotation.    
   The level of detail ranges from mentioning only the pairs of interacting partners and heuristic scores assigned to them (for instance, STRING) to the ones containing experiment details (detection method, bait/prey status, if available - quantitative data, experiment setup, protein variants), such as IntAct [@Orchard:2014aa].  
   The amount of interaction data generated per year is growing exponentially making manual curation of all this data into primary databases a daunting task. To prioritise curation efforts and reduce redundancy between databases (to curate different data using the same standards) IMEx consortium was formed in 2012 [@Orchard:2012aa]. IMEx-compliant databases include primary databases such as IntAct and MINT, but doesn't include BioGRID (which curates at the lower level of detail) and no longer active databases such as HPRD [@Peri:2004aa] and BIND [@Isserlin:2011aa].  

# Motivation for this study

   Solving some of these challenges may be easier than the others. In particular, to solve the last challenge we can prioritise curation efforts for already published interactions to cover unrepresented proteins and we can encourage authors to submit their results to the databases prior to publishing. We can also encourage research of underrepresented parts of the interactome. This motivates the need to characterise the interactome already present in interaction databases. More specifically, we need to measure how available interactome covers the proteome of main model species, if there are any biases towards proteins with or without available interactions and if major protein interaction detection methods exhibit biases towards specific groups of proteins. These results can be also used to inform data integration projects and show the need to adjust for biases when studying protein-protein interactions network.  

# Aims of the study 

1. Describe the coverage of the proteome of main model species. Considering either all UniProtKB or SwissProt entries only as the proteome (canonical identifiers as well as protein isoforms). Consider all interactions from IMEx-compliant databases as interactome.    

2. Compare the coverage of the proteome by interaction evidence from IMEx to the interaction evidence from BioGRID (the other major primary database).  

3. Investigate if proteins with no available interactions stand out by specific functions (Gene Ontology, GO: biological process and molecular function), cellular localisation (GO), molecular mass, or protein evidence status from SwissProt  

4. Find out if major protein interaction detection methods (two-hybrid and AP-MS) exhibit any bias towards biochemical properties of the proteins involved (mass, disordered regions, hydropathy, the fraction of charged residues)  


# Methods: data processing and analysis

### Getting proteome from UniProtKB

   Whole proteome (all UniProtKB) for each species was downloaded programmatically in R using UniProt rest API. SwissProt-proteome was subset from the whole proteome by reviewed status column. UniProt identifies proteins by UniProtKB/AC (e.g. P04637, accession) which does not distinguish between protein isoforms. UniProt aggregates isoform information and identifiers (e.g. P04637-4) in a separate column with zero to many isoforms per each UniProtKB accession. To generate proteome list which includes protein isoforms, isoform accessions were extracted and combined with the list of generic accessions. In this analysis, protein evidence status and protein mass are only attributed to generic accessions. 

### Getting and transforming interactome data from IMEx databases and BioGRID

   Interactome from all IMEx databases was downloaded programmatically in R using PSIQUIC package from Bioconductor [@PSICQUIC]. The list of interactions (pairs of interactors) was transformed into the list of interactors preserving interactor identifiers, the type of interactor identifier, species information and the database interaction originates from. Only unique proteins wereIMEx databases contain interactions between proteins, RNA, DNA and small molecules, moreover, these interaction may involve molecules originating from different species. Therefore, to perform by species interactome/proteome comparison there is a need to remove non-UniProtKB/AC molecule identifiers (which removes non-protein molecules, although, may also remove a small fraction of proteins which have no UniProtKB/AC) and there is a need to remove proteins originating from other species. Also, entries in IMEx databases has to be cleaned of tags and textual descriptions ("taxid:9606(human-h1299)|taxid:9606(Homo sapiens lung lymph node carcinoma)" to "9606") to make further analysis easier and cleaner.
   Next, when provided in the research articles protein isoform information is always included in IMEx databases, so to perform analysis excluding isoform information UniProtKB/AC were cleaned of -N suffix (P04637-4 to P04637).
   IMEx consortium databases such as IntAct, MINT, BHF-UCL, MPIDB, MatrixDB, HPIDb, I2D-IMEx, InnateDB-IMEx, MolCon, UniProt, MBInfo are currently integrated into IntAct [@Orchard:2014aa]. Data from all these databases was used in the analysis and reffered to as IntAct data or IMEx data.


### Physicochemical properties and disordered region prediction

   Information on disordered region content and physicochemical properties of individual proteins were obtained from the dataset generated by Vincent and  Schnell in 2015 [@Vincent:2016aa]. Briefly, Vincent and  Schnell used a number of disorder prediction algorithms (IUPred and DisEMBL) and their consensus to generate disordered region predictions for each protein which was be used to calculate the fraction of disordered regions in a protein. In addition, Vincent and  Schnell used localCIDER version 0.1.7 (Classification of Intrinsically Disordered Ensemble Regions) to calculate physical properties such as fraction of charged residues, mean hydropathy or charge separation for each protein. This was done for 10 eukaryotic proteomes and written to SQLite-database which was made available online through dryad service [@dryad_sm107].

### Gene Ontology enrichment analysis

   Enrichment analysis can identify groups of genes seletively enriched or depleted in a specific dataset. Genes can be grouped by common annotations decribing their function, location in the cell or membership in a pathway, such as those described in KEGG [@Kanehisa:2016aa] or Reactome [@Fabregat:2016aa]. Gene Ontology Consortium (GO) [@Gene-Ontology:2015aa] annotates gene products (proteins, non-coding RNA, protein complexes) by molecular fuction they perform, cellular component they are located in and biological process they are involved in. This annotation is first done manually by a curator based on evidence provided in the research paper and then expanded to other proteins using computational annotation methods, for example, mouse orthologues of human protein are likely to have similar function. Computational annotation is less reliable however it allows to generate at annotations for non-studied proteins or in poorely studied organisms. More information on the evidence codes for Gene Ontology annotations can be found on the GO Consortium website [http://geneontology.org/page/guide-go-evidence-codes]. All analyses in this study included all Gene Ontology annotations.  
   Enrichment analysis uses statistical tests and protein to GO term associations to identify functions and compartments overrepresented in a particular list of proteins as compared to background list. Statistical test is performed for every GO term and uses hypergeometric distubution to estimate the probability that a number of proteins in our list is annotated by a speficic GO term by chance based on the fraction of proteins annotated with that term in the background list. Calculated probality tells how likely (by chance) is that our list is enriched in proteins with function described by that specific GO term. If that's highly unlikely to occur by chance we consider GO function to be enriched. Multiple hypothesis testing correction is applied to adjust probabilies for higher probability of getting extreme result by chance due to testing thousands of GO terms. All enrichment test were performed and visualised using R package clusterProfiler [@Yu:2012aa]. GO annotations used in the clusterProfiler package are compiled from GO consortium into R package GO.db [@GO.db] provided through Bioconductor project [@Gentleman:2004aa].  
   
### Computational analysis: code

All R code used in this analysis in deposited to a public Github repository [@VKleshchevnikov2017], which is a common code-sharing resource.  
  
# Results

## 1. How well available interactome covers the proteome

```{r IMEx_vs_Uniprot_processing, cache=F}
# if the analysis has been done - don't do it again
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
filename.summary.all2 = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",date,".txt", sep = "")
filename.summary.all3 = paste("./results/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",date,".txt", sep = "")
if(!file.exists(filename.summary.all)){

SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")

## ## Use all Uniprot if reviewed == 1, only Swissprot data if reviewed == 2, 
## ## TrEMBL data if reviewed == 3
reviewed = c(1, 2)

## ## Distinguish between isoforms or use only generic Uniprot IDs: TRUE / FALSE?
isoforms = c(TRUE, FALSE)

## missing_proteins = TRUE => proteins missing protein evidence are shown
## missing_proteins = FALSE => proteins for which protein evidence exists are shown
missing_proteins = TRUE

## The code below queries databases, saves and processes results, 
## gives summary on how many interactors have Uniprot IDs or belong to the SPECIES_NAME
## generates table with 0 and 1 for the combination of SPECIES_NAME, reviewed, isoforms

  ## type in exact database names (the list below is the default for the function)
  databases <- c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
                 "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")

source("intact_vs_uniprot.R")
for (i in isoforms) {
  for (r in reviewed) {
    for (n in SPECIES_NAME) {
      intact_vs_uniprot(SPECIES_NAME = n, reviewed = r, isoforms = i, missing_proteins = TRUE, date = date, databases = databases)
      message(paste("- ",n," -  reviewed", r, " -  isoforms included", i))
    }
  }
}

## The code below does overlap comparisons and saves summaries
source("intact_vs_uniprot_overlap.R")
source("SPECIES_NAME_TO_ID.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      intact_vs_uniprot_overlap(SPECIES_NAME = n, SPECIES_ID = SPECIES_ID, reviewed = r, isoforms = i, date)
      message(paste("- ",n," -  reviewed", r, " -  isoforms included", i))
    }
  }
}

### combine the summaries for multiple species
proteome_vs_interactome_summary.all = data.frame()
whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all = data.frame()
whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all = data.frame()
for (r in reviewed) {
  for (i in isoforms) {
    for(n in SPECIES_NAME) {
      #=====================================
      filename.summary = paste("./summaries/","proteome_vs_interactome_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary)) {
        proteome_vs_interactome_summary.all
      }
      if(file.exists(filename.summary)) {
        proteome_vs_interactome_summary_o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
        proteome_vs_interactome_summary.all = rbind(proteome_vs_interactome_summary.all, proteome_vs_interactome_summary_o)
      }
      #=====================================
      filename.summary2 = paste("./summaries/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary2)) {
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all
      }
      if(file.exists(filename.summary2)) {
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist = as.data.frame(read.delim(filename.summary2, stringsAsFactors = F))
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all = rbind(whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all, whole_proteome_Uniprot_vs_IMEx_vs_protein.exist)
      }
      #=====================================
      filename.summary3 = paste("./summaries/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary3)) {
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all
      }
      if(file.exists(filename.summary3)) {
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist = as.data.frame(read.delim(filename.summary3, stringsAsFactors = F))
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all = rbind(whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all, whole_proteome_Uniprot_vs_IntAct_vs_protein.exist)
      }
  }
}
}
## save all species summary
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
write.table(proteome_vs_interactome_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)
filename.summary.all2 = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",date,".txt", sep = "")
write.table(whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all, filename.summary.all2, col.names=T,row.names=F,sep="\t",quote=F)
filename.summary.all3 = paste("./results/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",date,".txt", sep = "")
write.table(whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all, filename.summary.all3, col.names=T,row.names=F,sep="\t",quote=F)
}

{
  if(file.exists(filename.summary.all)) proteome_vs_interactome_summary.all = fread(filename.summary.all, sep = "\t", stringsAsFactors = F, data.table = F)
}
```

### Available interactome covers substantial fraction of the reviewed proteome of main model species

   In this section, we compare the proteome, the list of all proteins in annotated Uniprot [@The-UniProt:2017aa], to the list of proteins which have interacting partners annotated in IMEx consortium databases. We compare the coverage across seven model species. We have also compared interactome coverage of the manually reviewed SwissProt (shown on the Figure 7.1) and the reviewed SwissProt and unreviewed trEMBL (all UniProtKB) combined shown on the Supplementary Figure 1.  
   Non-canonical protein isoform identifiers (P32054-1) were converted to canonical identifiers (P32054) resulting in interactions "any isoform to any isoform" (Venn diagrams on the right) or isoform identifiers were preserved (Venn diagrams on the left). You can see that adding isoform information adds more proteins to the SwissProt list but not so many proteins to the IMEx list.  

```{r IMEx_vs_Uniprot_venndiagram, cache=F, fig.width=8, fig.height=8, fig.cap="The best coverage is observed for yeast, E.coli and human. Isoform coverage is limited, but still significant for human. Red circles represent proteins which have interacting partners curated in IntAct, blue circles represent proteins in SwissProt, taking into account isoforms (left) or canonical identifiers (right)."}
## Plotting with venn.diagram - Uniprot vs IMEx
# code to be modified for different graphs
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
reviewed_venn = 2                 # 1 or 2
IMExdatabase_sel = "IMEx"    # subset the results "X0469.IntAct." or "IMEx"
IMExdatabase_label = "IntAct" # show on the plot
### ======================================================================== ###
# non-modifyable code
proteome_vs_interactome_summary.all$species.name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", proteome_vs_interactome_summary.all$species.name)
proteome_vs_interactome_summary.all$species.name = gsub("strain K12", "Escherichia coli, strain K12", proteome_vs_interactome_summary.all$species.name)
SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", SPECIES_NAME)
SPECIES_NAME = gsub("strain K12", "Escherichia coli, strain K12", SPECIES_NAME)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn & isoforms == TRUE & database == IMExdatabase_sel)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn & isoforms == FALSE & database == IMExdatabase_sel)

library(VennDiagram)
{
source("double.venn.prot.R")
grid.newpage()

if(reviewed_venn == 2){plotname = paste0("Proteome (SwissProt) coverage by interaction databases(",IMExdatabase_label,")")
databasename = "SwissProt"}
if(reviewed_venn == 1){plotname = paste0("Proteome (all UniprotKB) coverage by interaction databases(",IMExdatabase_label,")")
databasename = "UniprotKB"}

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("isoforms included", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  venn = double.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = FALSE, IMExdatabase = IMExdatabase_label)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  venn = double.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = FALSE, IMExdatabase = IMExdatabase_label)
  popViewport()
}
popViewport()
}

human_isoform = proteome_vs_interactome_summary.all_isof$whole.proteome..Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] - proteome_vs_interactome_summary.all_noisof$whole.proteome..Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"]

human_isoform_with_interactions = proteome_vs_interactome_summary.all_isof$whole.proteome..interactome.available[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] - proteome_vs_interactome_summary.all_noisof$whole.proteome..interactome.available[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] + (proteome_vs_interactome_summary.all_isof$interactome..but.not.in.Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] - proteome_vs_interactome_summary.all_noisof$interactome..but.not.in.Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"])
```

   The best interactome annotated by IMEx databases is baker’s yeast, 2nd best interactome is *E.coli*. All other interactomes cover less than the half of their respective proteome (all UniProtKB, Supplementary figure 1). The overlap between the interactome and reviewed proteome (SwissProt) is significantly better.   
   A large fraction of human, mouse, arabidopsis proteins and more than a half of drosophila and *C.elegans* proteins are absent in SwissProt (but included in trEMBL) – suggesting under-annotation by the SwissProt-Uniprot team.  
Protein isoforms (in multicellular model organisms) are almost not annotated in the interactome. Human is an exception: out of `r human_isoform` protein isoforms annontated by SwissProt `r human_isoform_with_interactions` protein isoforms have interacting partners. Other molecular interaction databases (active BioGRID, inactive HPRD) do not record isoform information.  

## 2. BioGRID database (as obtained from Mentha) overlaps significantly with IMEx databases

   BioGRID database is a major primary protein interaction database [@Chatr-Aryamontri:2017aa]. IntAct and BioGRID combined contain all interaction information which has been curated to currently active public databases (major inactive databases include HPRD [@Peri:2004aa] and BIND [@Isserlin:2011aa]). BioGRID uses shallow curation level (retains only some information about the interaction and the experiment) and identifies proteins using Entrez Gene ID while IntAct uses UniProtKB identifiers. This has allowed BioGRID to curate more interaction data, for example, BioGRID currently contains interaction data from 25307 publications and compared to only 11130 in IMEx (human data only considered), more information can be found: https://github.com/vitkl/darkspaceproject/blob/master/BioGRID/BioGRID_dsgen.md).  
   One of the main drawbacks of BioGRID curation model is that the use of Entrez Gene ID does not allow to distinguish between different protein encoded by the same gene or different protein isoforms, specify sufficient-to-bind regions of the protein. In our analysis, this difference introduces additional identifier mapping step (Gene ID to UniProtKB), which generates redundancy and ambiguity: several proteins can be coded by one gene and several genes can code single proteins. Mentha database [@Calderone:2013aa] has imported all BioGRID-stored interactions and has mapped Gene ID to UniProtKB, so we used Mentha to get BioGRID-stored interactions. Mentha doesn't import interactions for *E.coli*, therefore *E.coli* is not present in this analysis.  
   BioGRID has recently incorporated a large-scale study aimed, in part, to find interacting partners of the proteins with no know interactions [@Huttlin:2015aa], which increases observed coverage by BioGRID. 

```{r biogrid_vs_IMEx_vs_Uniprot_processing}
filename.summary.all_biog = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_summary_",date,".txt", sep = "")
if(!file.exists(filename.summary.all_biog)){
  
## Enter SPECIES_NAME 
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
## !! no "E.coli strain K12" in BioGRID from Mentha
## ## Use all Uniprot if reviewed == 1, only Swissprot data if reviewed == 2, 
## ## TrEMBL data if reviewed == 3
reviewed = c(1, 2)
## ## Distinguish between isoforms or use only generic Uniprot IDs: TRUE / FALSE?
isoforms = c(FALSE) # not possible to distinguish isoforms for BioGRID

#============================================================================#
source("biogrid_from_mentha_vs_proteome_vs_imex.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
        biogrid_from_mentha_vs_proteome_vs_imex(SPECIES_NAME = n, reviewed = r, isoforms = i, date = date)
    }
  }
}

whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = data.frame()
reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = data.frame()
whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha = data.frame()
source("SPECIES_NAME_TO_ID.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",reviewed = r,"_isoforms_",isoforms = i,"_", date,".txt", sep = "")
      biogrid_from_mentha_vs_proteome_vs_imex_f = as.data.frame(read.delim(filename_vs_3, stringsAsFactors = F))

#============================================================================#
## Calculating overlaps

source("A_vs_B_vs_C_overlap.R")
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                    A = "whole_proteome_Uniprot", 
                    B = "IMEx", 
                    C = "BioGRID_from_Mentha", 
                    SPECIES_NAME = n, reviewed = r, isoforms = i)
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = rbind(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp)

whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                                                                                 A = "whole_proteome_Uniprot", 
                                                                                 B = "X0469.IntAct.", 
                                                                                 C = "BioGRID_from_Mentha", 
                                                                                 SPECIES_NAME = n, reviewed = r, isoforms = i)
whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha = rbind(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha_temp)

reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                                                                                 A = "reference_proteome_Uniprot", 
                                                                                 B = "IMEx", 
                                                                                 C = "BioGRID_from_Mentha", 
                                                                                 SPECIES_NAME = n, reviewed = r, isoforms = i)
reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = rbind(reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp)
    }
  }
}
write.table(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, filename.summary.all_biog, col.names=T,row.names=F,sep="\t",quote=F)
}

{
  if(file.exists(filename.summary.all_biog)) whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = fread(filename.summary.all_biog, sep = "\t", stringsAsFactors = F, data.table = F)
}
```

```{r biogrid_vs_IMEx_vs_Uniprot_venndiagram, cache=F, fig.width=8, fig.height=8, fig.cap="BioGRID and IMEx share a considerable fraction of proteins with interaction data. Red circles represent proteins which have interacting partners curated in IntAct, blue circles represent proteins in SwissProt, green circles represent proteins which have interacting partners curated in BioGRID, taking into account all UniProtKB (left) or only manually reviewed SwissProt (right) proteins, only canonical identifiers considered." }
## Plotting overlaps - Uniprot IMEx BioGRID
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
IMExdatabase_label = "IntAct" # show on the plot
### ======================================================================== ###
# non-modifyable code
if(IMExdatabase == "IMEx"){
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha$species_name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha$species_name)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reviewed == 1)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reviewed == 2)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
}
if(IMExdatabase == "X0469.IntAct."){
  whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha$species_name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha$species_name)
  library(dplyr)
  proteome_vs_interactome_summary.all_isof = filter(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, reviewed == 1)
  proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == FALSE)
  proteome_vs_interactome_summary.all_noisof = filter(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, reviewed == 2)
  proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
}
library(VennDiagram)
{
grid.newpage()

plotname = paste0("Proteome coverage by interaction databases, overlap between ", IMExdatabase_label," and BioGRID")

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("UniprotKB, isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("SwissProt, isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("triple.venn.prot.R")
  venn = triple.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = TRUE)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("triple.venn.prot.R")
  venn = triple.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = TRUE)
  popViewport()
}
popViewport()
}
```

   Overall, BioGRID overlaps with IMEx to a large extent. Nonetheless, for all of the species we have looked at, BioGRID has annotated some proteins (and their interactions) which are not annotated in IMEx. BioGRID stores substantially more interactions for arabidopsis and a considerable fraction of human and mouse interactions.  
   
##3. Mouse and human proteins are commonly combined for interaction experiments

   The fact that researchers tend to put proteins from other species (mostly human) into mouse experiments or tend to put mouse proteins into cells from other species (mostly human) is also common for interaction detection experiments and is clearly seen in Figure 7.3: half of the mouse interactors are from the other species. This holds true both for IMEx databases (Figure 7.3) and for BioGRID (Supplementary figure 2); however, this analysis doesn't show which proteins (mouse or human) were used as bait to capture interactions in which cells (mouse or human).  

```{r IMEx_vs_Uniprot_N_Uniprot_Species, cache=F, fig.width=8, fig.height=8, fig.cap="Mouse and human proteins are commonly combined for interaction experiments. Red bar shows the number of proteins from a given species, blue bar shows the number of proteins from another species. Red group proteins form interactions both with red and blue group proteins, blue group proteins form interactions only with red group proteins" }
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
isoforms = FALSE
### combine the summaries for multiple species of how many interactors have non-uniprot and non-given-species identifiers
interactome_identifiers_summary.all = data.frame()
  for (i in isoforms) {
    for(n in SPECIES_NAME) {
      filename.summary = paste("./summaries/","uniprotKB_IDs_and_",n,"_interactors_summary_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary)) {
        interactome_identifiers_summary.all
      }
      if(file.exists(filename.summary)) {
        interactome_identifiers_summary.o = as.data.frame(fread(filename.summary, stringsAsFactors = F, data.table = F))
        interactome_identifiers_summary.all = rbind(interactome_identifiers_summary.all, interactome_identifiers_summary.o)
      }
    }
  }
interactome_identifiers_summary.all = unique(interactome_identifiers_summary.all)
## Plotting the number of interactors which have UniprotKB identifiers and belong to the species queried
interactome_identifiers_summary.all.s = interactome_identifiers_summary.all[,c(3,4,5,6,7)]
## Transform table for plotting with ggplot2
library(reshape2)
interactome_identifiers_summary.all.s.m= melt(data = interactome_identifiers_summary.all.s,
                                              id.vars = c("SPECIES_NAME", "SPECIES_ID"),
                                              variable.name = "decription",
                                              value.name = "number")
## rename yeast and E.coli
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain K12", "E. coli, strain K12", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Caenorhabditis elegans", "C. elegans", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Drosophila melanogaster", "D. melanogaster", interactome_identifiers_summary.all.s.m$SPECIES_NAME)

# filter out non-uniprot identifiers to make picture clearer
interactome_identifiers_summary.all.s.m$decription = gsub("\\.", " ", interactome_identifiers_summary.all.s.m$decription)
ind = interactome_identifiers_summary.all.s.m$decription != "interacting partners with the other identifier"
interactome_identifiers_summary.all.s.m = interactome_identifiers_summary.all.s.m[ind,]

# plot how many interactors have non-uniprot and non-given-species identifiers
library(ggplot2)
library(dplyr)
ggplot(interactome_identifiers_summary.all.s.m, aes(x=SPECIES_NAME, y=number, fill=decription)) + geom_bar(width = 0.9, stat = "identity", position = "stack") + geom_label(aes(label=number), position = "stack", size = 4, label.padding = unit(0.08, "lines")) +
  ggtitle("The number of interacting partners which have UniprotKB identifiers \n and belong to the species of interest") + theme(axis.text.x=element_text(angle = 20), axis.title.x = element_text(size = 0)) + ylab("number of proteins")
# save plot
# filename=paste("./results/", "interactome_identifiers_summary_plot_SMALL",date,".png", sep = "")
# ggsave(filename, proteome_vs_interactome_plot, width = 12, height = 12)
```

   Interchangeable use of mouse and human proteins generates interaction data which is hard to reuse and introduces imprecision due to the fact that it requires the mapping between homologous proteins; however, this may not be the biggest problem with studying the interactions between mouse and human proteins and trying to correctly interpret results. Recent studies of intrinsically disordered proteins show that linear amino acid motifs located in disordered regions frequently mediate protein-protein interactions [@Babu:2016aa], for example, the disordered region of p53 mediates its ability to recruit transcription-activating proteins to the promoter [@Buljan:2012aa]. More importantly, these linear amino acid motifs can evolve quickly, for example, allowing cancer cells to escape control by P53 [@Buljan:2012aa]. So, while the interaction between mouse protein A and human protein B can exist, that might not be true for the interaction between human protein A and human protein B, and vice-verse.  
   On the other hand, some researchers advocate that interactions important for the cellular function should be conserved between species [@Li:2017aa].  

```{r dowlnload_all_IntAct, cache=F, fig.width=8}
# IntAct FTP contains the following databases = c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
#               "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")
# this will take time and data traffic ~ 2.5GB

url_intact = "ftp://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.txt"
filename_intact = paste0("./Data/IntAct_MITAB27_release_", format(Sys.Date(), "%m-%Y.txt"))
if(!file.exists(filename_intact)) {
  downloader::download(url_intact, filename_intact)
  }
# Read all IntAct
library(data.table)
all.IntAct = fread(filename_intact)
# changing column names to data.table-compatible format
{
(colnames_IntAct = colnames(all.IntAct))
colnames(all.IntAct) = gsub(" ","_",colnames(all.IntAct))
colnames(all.IntAct) = gsub("\\(|\\)","",colnames(all.IntAct))
colnames(all.IntAct) = gsub("#","",colnames(all.IntAct))
}
# cleaning Taxid "taxid:9606(human)|taxid:9606(Homo sapiens)" to 9606
all.IntAct = all.IntAct[,.(IDs_interactor_A, IDs_interactor_B, Experimental_roles_interactor_A, Experimental_roles_interactor_B,  Taxid_interactor_A, Taxid_interactor_B, Host_organisms, Publication_Identifiers, Confidence_values, Interaction_identifiers, Expansion_methods)]
{
all.IntAct[, Taxid_interactor_A := gsub("taxid:|\\(.*$","",Taxid_interactor_A)]
all.IntAct[, Taxid_interactor_B := gsub("taxid:|\\(.*$","",Taxid_interactor_B)]
all.IntAct[, Host_organisms := gsub("taxid:|\\(.*$","",Host_organisms)]
# saving identifier types and cleaning interactor ids
all.IntAct[, interactor_IDs_databases_A := gsub(":.*$","",IDs_interactor_A)]
all.IntAct[, interactor_IDs_databases_B := gsub(":.*$","",IDs_interactor_B)]
all.IntAct[, IDs_interactor_A := gsub("^.*:","",IDs_interactor_A)]
all.IntAct[, IDs_interactor_B := gsub("^.*:","",IDs_interactor_B)]
# cleaning other information
all.IntAct[, bait_prey_status_A := gsub("^.*\\(|\\)","",Experimental_roles_interactor_A)]
all.IntAct[, bait_prey_status_B := gsub("^.*\\(|\\)","",Experimental_roles_interactor_B)]
all.IntAct[, Publication_Identifiers := gsub("^.*pubmed:|\\|.*$","",Publication_Identifiers)]
all.IntAct[, Confidence_values := gsub("^intact-miscore:","",Confidence_values)]
all.IntAct[, Confidence_values := gsub("-","NA",Confidence_values)]
all.IntAct[, Confidence_values := as.numeric(Confidence_values)]
all.IntAct[, Interaction_identifiers := unlist(gsubfn::strapplyc(Interaction_identifiers,"EBI-[[:digit:]]+",simplify = T)), by =Interaction_identifiers]
}

# checking mixed mouse / human interactions
{
the_host_for_mouse_human_pairs = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb"
           , table(Host_organisms)]
the_host_for_mouse_human_pairs_mouse_as_bait = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey"))
           , table(Host_organisms)]
mouse_as_bait = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey")) &
              Host_organisms == "9606"
           ,.(IDs_interactor_A, IDs_interactor_B, Taxid_interactor_A, Taxid_interactor_B)]
mouse_as_bait_human_preys = length(unique(c(mouse_as_bait[(Taxid_interactor_A == "9606"), IDs_interactor_A], 
                mouse_as_bait[(Taxid_interactor_B == "9606"), IDs_interactor_B])))
mouse_as_bait_mouse_baits = length(unique(c(mouse_as_bait[(Taxid_interactor_A == "10090"), IDs_interactor_A], 
                mouse_as_bait[(Taxid_interactor_B == "10090"), IDs_interactor_B])))
N_pmid_mouse_as_bait_in_human = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey")) &
              Host_organisms == "9606"
           ,length(unique(Publication_Identifiers))]
all.IntAct[Taxid_interactor_A == "9606" & Taxid_interactor_B == "9606", table(Host_organisms)]
}

```

   Surprisingly, `r the_host_for_mouse_human_pairs[["9606"]]` interactions between mouse and human proteins were discovered in human rather than mouse cells (only `r the_host_for_mouse_human_pairs[["10090"]]`) suggesting that researchers use mouse rather than human proteins as baits (`r mouse_as_bait_mouse_baits` mouse baits total, `r mouse_as_bait_human_preys` human preys total, including isoforms, from `r N_pmid_mouse_as_bait_in_human` publications) to find interactions directly relevant to human interactome research, including human disease.  
   
## 4. Which proteins are missing interaction evidence?

   Characterising the properties of proteins missing interaction evidence can help prioritise curation efforts. By looking for proteins missing interaction evidence and involved in particular biological function (as described by Gene Ontology) we can complete missing part of the interactome and decrease bias towards well-studied proteins.   

```{r human_not_in_IMEx_protein_properties_processing}
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
     ##============================================================================##
      ## querying Uniprot for the list of proteins (only mapped to Uniprot)
      ## downolading length, mass, SNPs, isoforms, annotation score, existence attribute
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      ## reading logic table and getting list of proteins
      if(n != "strain K12"){
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")}
      if(n == "strain K12"){
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")}
      biogrid_from_mentha_vs_proteome_vs_imex_f = as.data.frame(read.delim(filename_vs_3, stringsAsFactors = F))
      source("download_whole_proteome.R")
      whole_proteome_query = download_whole_proteome(SPECIES_ID, date = date)
      colnames(whole_proteome_query)[2] = "Status"
      uniprot_query = dplyr::filter(whole_proteome_query, Status == "reviewed")
      ##============================================================================##
      ## merging information from Uniprot to the logic table
      proteome_vs_imex_details_f = merge(filter(biogrid_from_mentha_vs_proteome_vs_imex_f, whole_proteome_Uniprot==1), 
                                         uniprot_query, 
                                         by.x = "whole_proteome_IDs",
                                         by.y = "Entry")
      proteome_vs_imex_details_f$Mass = gsub(",","",proteome_vs_imex_details_f$Mass)
      proteome_vs_imex_details_f$Mass = as.numeric(proteome_vs_imex_details_f$Mass)
      ## creating a factor variable for presence_in_Uniprot.presence_in_IMEx (1_0/1_1)
      proteome_vs_imex_details_f[,length(proteome_vs_imex_details_f)+1] = interaction(proteome_vs_imex_details_f$whole_proteome_Uniprot, proteome_vs_imex_details_f$IMEx, sep = "_")
      colnames(proteome_vs_imex_details_f)[length(proteome_vs_imex_details_f)] = paste0(colnames(proteome_vs_imex_details_f)[2], "_","IMEx")
      levels(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx) = c("SwissProt_not_IMEX", "SwissProt_and_IMEX")
      ##============================================================================##
      ## saving combined logic table + protein properties from Uniprot
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      write.table(proteome_vs_imex_details_f,filename_vs_2,col.names=T,row.names=F,sep="\t",quote=F)
    }
  }
  }
```

### Olfactory receptors are a major group of human proteins not represented in IntAct

We have performed Gene Ontology enrichment analysis of proteins with no available interactions as compared to whole proteome (SwissProt protein list). We have looked at overrepresented biological processes, molecular fuctions and cellular compartment localisation of proteins. Here only overrepresented biological processes are shown.  

```{r human_not_in_IMEx_protein_properties_GO_BP, fig.width=10, fig.height=8, fig.cap="Overrepresented biological processes. The size of the dot shows the number of proteins of that category in the dataset (proteins without interaction), x-axis represents the fraction of proteins of that category in the dataset. Colour shows the probability of that overlap occurring by chance."}
##====================================================================
suppressPackageStartupMessages({
      library(data.table)
      library(qvalue)
      library(ggplot2)
      })
##====================================================================
# read the saved table
SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = fread(filename_vs_2, header = T, stringsAsFactors = F,quote="")
##====================================================================

      not_in_IMEx_BP = GO_enrich_simplify_plot_bioc(protein_set = unique(proteome_vs_imex_details_f[whole_proteome_Uniprot == 1 & IMEx == 0,whole_proteome_IDs]),
                                   reference_protein_set = unique(proteome_vs_imex_details_f[whole_proteome_Uniprot == 1,whole_proteome_IDs]),
                                   identifier_type = "UNIPROT", ontology = "BP", 
                                   pAdjustMethod_ = "BH", 
                                   minSetSize = 40, maxSetSize = 430, 
                                   simplify_by = "GeneRatio", 
                                   simplify_fun = "function (x) x[which.max(eval(parse(text = paste0(\"c(\",paste0(x, collapse = \",\"),\")\"))))]", 
                                   similarity_calc_method = "Wang", 
                                   similarity_cutoff = 0.8, 
                                   visualize_result = "dotplot", 
                                   above_corrected_pval = 0.05, 
                                   use_bioc_annotationdbi = T, 
                                   plot_title = "biological function of proteins with no interactions in IntAct",
                                   xlabel = "the fraction of proteins with a specific biological function \namong proteins with no interactions",
                                   drop_GO_levels = c(1:3,15:20))
      print(not_in_IMEx_BP$plot + theme(plot.title = element_text(hjust = 0.8)))
      
```

Most of the proteins missing interactions are smell receptors, ion channels, adhesion molecules, lipid synthesys enzymes, taste receptors. A minor category of proteins involving sperm-egg recognition is also overrepresented. As you might infer, all these proteins are transmembrane or are connected to the membrane, which is also supported by enrichment analysis for GO cellular component. We can speculate that olfactory receptors are numerous and according to our current knowledge, similar in function, therefore this group has not attracted enough interest to study it's protein-protein interactions. Nonetheless, transmembrane proteins are challenging to perform protein-protein interactions studies on.  

### Human proteins with no available interactions are on average shorter than the proteins with interactions available  

   Protein length or mass are physical properties of a protein which can, in theory, influence it's usage as a bait in experiments and it's detection in case methods depend on protein length. Proteins length is also important biologically. Longer proteins can have multiple functional domains and, therefore, more interactions.
The distribution of protein mass has a very long right tail - there are much more big proteins than a normal distribution would predict (Supplementary figure 3), which only allows the use of non-parametric statistical tests (Wilcox test is a pairwise test we have chosen). Log10 transformation of protein mass, though, makes extreme values less extreme and is approximately normally distributed.  

```{r human_not_in_IMEx_proteins_are_shorter_density, fig.width=7, fig.height=5, fig.cap="Human proteins with no available interactions are on average shorter than the proteins with interactions available. The plot compares the distribution of protein mass across SwissProt proteins with or without interacting partners in IntAct. Vertical line highlights the median." }
      ## Analysis
      # read the saved table
SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
      proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)
                  ## plotting the distribution of mass
      library(ggplot2)
      # ggplot(proteome_vs_imex_details_f, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.5)) +geom_density()+ scale_x_log10()
      # ggplot(proteome_vs_imex_details_f, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.5)) + scale_x_log10() + geom_histogram(position = "identity", bins = 50)
      
      ## removing olfactory receptors:
      {proteome_vs_imex_details_f_minus_odor = proteome_vs_imex_details_f[-grep("Odor", 
                                                                                proteome_vs_imex_details_f$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf = proteome_vs_imex_details_f_minus_odor[-grep("Olfactory",
                                                                                              proteome_vs_imex_details_f_minus_odor$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf.c = rbind(cbind(proteome_vs_imex_details_f, olfac = 
                                                              rep("all SwissProt", nrow(proteome_vs_imex_details_f))),
                                                        cbind(proteome_vs_imex_details_f_minus_odor_olf, olfac = rep("SwissProt excluding \n olfactory receptors",nrow(proteome_vs_imex_details_f_minus_odor_olf))))}
      
      # the number of odor receptors excluded
n_odor_receptors = length(unique(grep("Odor", proteome_vs_imex_details_f$Protein.names, value = F))) + length(unique(grep("Olfactory", proteome_vs_imex_details_f_minus_odor$Protein.names, value = F)))

# calculating median per group
proteome_vs_imex_details_f_minus_odor_olf.c = as.data.table(proteome_vs_imex_details_f_minus_odor_olf.c)
proteome_vs_imex_details_f_minus_odor_olf.c[, whole_proteome_Uniprot_IMEx_x_olfac := paste0(whole_proteome_Uniprot_IMEx,olfac)]
proteome_vs_imex_details_f_minus_odor_olf.c[, median_Mass_per_group := median(log10(Mass)), by = whole_proteome_Uniprot_IMEx_x_olfac]

proteome_vs_imex_details_f_minus_odor_olf.c[, in_IntAct := ifelse(whole_proteome_Uniprot_IMEx == "SwissProt_and_IMEX", "yes", "no")]

          ## histogram with and without olfactory receptors:
      ggplot(proteome_vs_imex_details_f_minus_odor_olf.c, aes(x = Mass, color = in_IntAct, label = olfac)) +geom_freqpoly(bins = 100)+ scale_x_log10() + theme(strip.text.y = element_text(angle = 0)) +xlab("protein mass, Da, log10 scale") + ggtitle("The distribution of protein mass for proteins with and \n without interacting partners curated in IMEx")+geom_vline(aes(xintercept = 10^median_Mass_per_group, color = in_IntAct),alpha =0.7)  + facet_grid(olfac~.)+
        geom_vline(aes(xintercept = 10^median_Mass_per_group, color = in_IntAct),alpha =0.7,size =1.5) +
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```

```{r human_not_in_IMEx_proteins_are_shorter_Wilcox}
           ## testing the difference in protein mass distributions
            ##of proteins absent/present in IMEx using Wilcox rank test
      SwissProt_not_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
      wilcox.test.r = wilcox.test(SwissProt_not_IMEX, SwissProt_and_IMEX, conf.int = T)
      ttest_r = t.test(log10(SwissProt_not_IMEX), log10(SwissProt_and_IMEX), conf.int = T)
                 ## testing the difference in protein mass distributions after removing odor receptors
            ##of proteins absent/present in IMEx using Wilcox rank test excluding olfactory receptors
      SwissProt_not_IMEX = proteome_vs_imex_details_f_minus_odor_olf$Mass[proteome_vs_imex_details_f_minus_odor_olf$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f_minus_odor_olf$Mass[proteome_vs_imex_details_f_minus_odor_olf$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
      wilcox.test.r.min.olf = wilcox.test(SwissProt_not_IMEX, SwissProt_and_IMEX, conf.int = T)
```

This difference in protein mass between proteins present and absent in the interactome is highly unlikely to occur by chance (Wilcox rank test (Mass, Da, 95% confidence interval: `r format(signif(wilcox.test.r$conf.int,3), scientific =F)`, p-value: `r format(signif(wilcox.test.r$p.value,3), scientific =F)`) and Student t-test(log10 of Mass, Da, 95% confidence interval: `r format(signif(ttest_r$conf.int,3), scientific =F)`, p-value: `r format(signif(ttest_r$p.value,3), scientific =F)`) on the whole population of proteins. The removal of `r format(signif(n_odor_receptors,3), scientific =F)` olfactory receptors, evidently, does not change this trend (Wilcox rank test on Mass, Da, 95% confidence interval: `r format(signif(wilcox.test.r.min.olf$conf.int,3), scientific =F)`, p-value: `r format(signif(wilcox.test.r.min.olf$p.value,3), scientific =F)`).  


## 5. Do major protein interaction detection methods (two-hybrid and AP-MS) exhibit a bias towards biochemical properties of the proteins?

   The problem of bias in interactomics is often discussed in research papes and in the community. Now we will focus on the bias of the experimental detection methods. We choose to compare two major families of methods: two-hybrid and affinity-purification followed by mass-spectrometry (AP-MS).  
   We identify two-hybrid method using PSI-MI ontology: detection method = "transcriptional complementation assay" (MI:0018) - all methods which belong to this type (which are children terms in the ontology). We identify AP-MS method using two PSI-MI ontology terms: detection method = "affinity chromatography technology" (MI:0004) and participant identification method = "partial identification of protein sequence" (MI:0433). The use of ontology terms for searching interaction allows to only specify a single term as opposed to listing every indivudual detection method included in those groups. One can browse ontology lookup service to identify which exact approaches are included under the umbrella of two-hybrid or affinity-purification-mass-spectrometry.  
   We fetch interactions detected using these methods by querying molecular interaction databases using PSICQUIC service.  

### AP-MS is biased towards longer proteins  

   We have compared interaction detection method bias towards protein mass across four species: *Homo sapiens*, *Mus musculus*, *S. cerevisiae* strain S288c, *Escherichia coli* strain K12. We observe that affinity-purification followed by mass-spectrometry (AP-MS) seems to capture a higher proportion of larger proteins as compared to two-hybrid methods. This pattern is present across four species that we looked at, however, is manifested to a different extent. To obtain a definitive explanation on the nature of the bias in experimental detection method in-depth analysis of the interaction data and the literature will be required, the goal of this study is only to identify how the bias is manifested.    


```{r querying_PSICQUIC_cleaning_and_transforming_interaction_types}

SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", SPECIES_NAME,"_reviewed_",reviewed,"_isoforms_",isoforms,"_", date,".txt", sep = "")
if(mean(file.exists(filename)) != 1){
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      

databases <- c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
               "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")

source("query_PSICQUIC_for_interactions.R")
twohybrids_all_interactions = query_PSICQUIC_for_interactions(SPECIES_ID = SPECIES_ID, 
                                                   SPECIES_NAME = n, 
                                                   databases = databases, date,
                                                   detmethod = "%22MI:0018%22") # %22 is a code for quote
complementation_all_interactions = query_PSICQUIC_for_interactions(SPECIES_ID = SPECIES_ID, 
                                                              SPECIES_NAME = n, 
                                                              databases = databases, date,
                                                              detmethod = "%22MI:0090%22")
ap_ms_all_interactions = query_PSICQUIC_for_interactions(SPECIES_ID = SPECIES_ID, 
                                                         SPECIES_NAME = n, 
                                                         databases = databases, date,
                                                         detmethod = "%22MI:0004%22",
                                                         pmethod = "%22MI:0433%22")

##=========================================================##
# extracting interactor ID-s from interactions (MI-TAB 2.7)
source("interactions_to_interactors.R")
twohybrids_all_interactors = interactions_to_interactors(twohybrids_all_interactions)
complementation_all_interactors = interactions_to_interactors(complementation_all_interactions)
ap_ms_all_interactors = interactions_to_interactors(ap_ms_all_interactions)

# filtering interactors for uniprotkb only indentifiers 
# filtering for SPECIES_ID only proteins
source("uniprotkb_and_SPECIES_ID_interactor_selector.R")
twohybrids_all_interactors_SPECIES_ID_only = uniprotkb_and_SPECIES_ID_interactor_selector(twohybrids_all_interactors, SPECIES_ID)
complementation_all_interactors_SPECIES_ID_only = uniprotkb_and_SPECIES_ID_interactor_selector(complementation_all_interactors, SPECIES_ID)
ap_ms_all_interactors_SPECIES_ID_only = uniprotkb_and_SPECIES_ID_interactor_selector(ap_ms_all_interactors, SPECIES_ID)

# Removing all isoform IDs (XXXXXX-X+ => XXXXXX) from IDs
  source("isoform_id_all_remover.R")
  twohybrids_all_interactors_SPECIES_ID_only$interactor_IDs = isoform_id_all_remover(twohybrids_all_interactors_SPECIES_ID_only$interactor_IDs)
  complementation_all_interactors_SPECIES_ID_only$interactor_IDs = isoform_id_all_remover(complementation_all_interactors_SPECIES_ID_only$interactor_IDs)
  ap_ms_all_interactors_SPECIES_ID_only$interactor_IDs = isoform_id_all_remover(ap_ms_all_interactors_SPECIES_ID_only$interactor_IDs)
  
# preparing interaction detection method data for logic table: selecting unique proteins and adding the column of ones
unique_twohybrids_interactors_SPECIES_ID_only = unique(cbind(twohybrids_all_interactors_SPECIES_ID_only[c("interactor_IDs")], 1))
colnames(unique_twohybrids_interactors_SPECIES_ID_only)[2] = "two_hybrid"
unique_complementation_interactors_SPECIES_ID_only = unique(cbind(complementation_all_interactors_SPECIES_ID_only[c("interactor_IDs")], 1))
colnames(unique_complementation_interactors_SPECIES_ID_only)[2] = "all_protein_complementation"
unique_ap_ms_interactors_SPECIES_ID_only = unique(cbind(ap_ms_all_interactors_SPECIES_ID_only[c("interactor_IDs")], 1))
colnames(unique_ap_ms_interactors_SPECIES_ID_only)[2] = "AP_MS"

# loading logic table made by "swissprot_vs_imex_protein_properties" script or by 
filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)

# merging new results with the logic table
proteome_vs_imex_interaction_details_t1 = merge(proteome_vs_imex_details_f, 
                                   unique_twohybrids_interactors_SPECIES_ID_only, 
                                   by.x = "whole_proteome_IDs",
                                   by.y = "interactor_IDs",
                                   all.x = T, all.y = F)
proteome_vs_imex_interaction_details_t2 = merge(proteome_vs_imex_interaction_details_t1, 
                                               unique_complementation_interactors_SPECIES_ID_only, 
                                               by.x = "whole_proteome_IDs",
                                               by.y = "interactor_IDs",
                                               all.x = T, all.y = F)
proteome_vs_imex_interaction_details_f = merge(proteome_vs_imex_interaction_details_t2, 
                                               unique_ap_ms_interactors_SPECIES_ID_only, 
                                                by.x = "whole_proteome_IDs",
                                                by.y = "interactor_IDs",
                                                all.x = T, all.y = F)
proteome_vs_imex_interaction_details_f[is.na(proteome_vs_imex_interaction_details_f)] = 0

# adding factor combination variable - two_hybrid and AP_MS
proteome_vs_imex_interaction_details_f[,length(proteome_vs_imex_interaction_details_f)+1] = interaction(proteome_vs_imex_interaction_details_f$two_hybrid, proteome_vs_imex_interaction_details_f$AP_MS, sep = "_")
colnames(proteome_vs_imex_interaction_details_f)[length(proteome_vs_imex_interaction_details_f)] = paste0("two_hybrid", "_vs_","AP_MS")
levels(proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS) = c("not two-hybrid, and not AP-MS", "two-hybrid, not AP-MS","not two-hybrid, AP-MS", "two-hybrid and AP-MS")
proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS = as.character(proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS)
proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS[proteome_vs_imex_interaction_details_f$IMEx!=1] = "not in IntAct"

# saving combined logic table with protein properties from Uniprot and interaction properties combined
filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
write.table(proteome_vs_imex_interaction_details_f,filename,col.names=T,row.names=F,sep="\t",quote=F)
    }
  }
}
}
```

```{r interaction_types_combine_and_plot,  fig.width = 11, fig.height = 7, fig.cap= "Plots show the distribution of protein mass across four model species separated by interaction detection method.  Details in text."}
# read the table saved before 
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
proteome_vs_imex_interaction_details_all = data.table()
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_interaction_details_f = as.data.table(fread(filename, header = T, stringsAsFactors = F,quote="", data.table = F))
n = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", n)
n = gsub("strain K12", "Escherichia coli, strain K12", n)
proteome_vs_imex_interaction_details_f[ , c("SPECIES_NAME","reviewed","isoforms", "SPECIES_ID") := list(n,r,i,SPECIES_ID)]
proteome_vs_imex_interaction_details_all = rbind(proteome_vs_imex_interaction_details_all,proteome_vs_imex_interaction_details_f, fill =T)
    }}}

proteome_vs_imex_interaction_details_all$two_hybrid_vs_AP_MS = factor(proteome_vs_imex_interaction_details_all$two_hybrid_vs_AP_MS, levels = c("not in IntAct", "not two-hybrid, and not AP-MS", "two-hybrid, not AP-MS", "not two-hybrid, AP-MS", "two-hybrid and AP-MS"))

proteome_vs_imex_interaction_details_all[, Median_mass := median((Mass)), by = .(SPECIES_NAME,two_hybrid_vs_AP_MS)]

proteome_vs_imex_interaction_details_all[,plot_labels := (paste0(gsub("_"," ",two_hybrid_vs_AP_MS),", (median mass: ", signif(Median_mass/1000,3)," kDa)"))]
proteome_vs_imex_interaction_details_all[,plot_labels := (paste0(signif(Median_mass/1000,3)," kDa)"))]

library(scales)
ggplot(proteome_vs_imex_interaction_details_all, aes(y = Mass, x =two_hybrid_vs_AP_MS, fill = two_hybrid_vs_AP_MS)) +
  geom_violin(draw_quantiles = c(0.05,0.25,0.495,0.5,0.505,0.75,0.95),scale = "area") +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))+
  ylab("Mass, Da, log10 scale")+
  xlab("in IntAct, interaction detection method")+
  ggtitle("protein mass by interaction detection method")+facet_grid(.~SPECIES_NAME)+theme(axis.text.x = element_text(angle =-35))+
   theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),panel.background = element_rect(fill = '#FFFFFF', colour = 'grey'))
```

   The statistical significance of the difference in protein mass across protein detection methods was tested using linear model approach. Linear model offers way to perform multiple statistical tests (ANOVA and posthoc ttests) in R. Linear model takes a group assignment for a protein (only two-hybrid, only AP-MS, both two-hybrid and AP-MS, other methods - a vector 0s and 1s where 1 show which group a protein belongs to) and the mass of that protein. Using these parameters for each of the proteins linear model can learn the mean of each group as well as provide a way to calculate errors for each of the between-group comparisons. The robust linear model used for this test is less sensitive to the extreme values.
   The figure 7.6 shows that the mass of the proteins which were identified interacting using AP-MS technique is on average higher that the mass of the proteins identified using two-hybrid or the other methods.  


### Major experimental role types (bait/prey/neutral component) are influenced by the mass of the protein in two-hybrid assays  

The experimental role of the protein (bait/prey/neutral component) can, in theory, be influenced by protein mass. For example, it may be easier to clone shorter proteins for use as bait/prey. So it important to see if the experimental role is really influenced by protein mass. We also factor in the interaction detection method.

```{r human_not_in_IMEx_bait_vs_non_bait, fig.width = 12, fig.height = 7, fig.cap="Experimental role of a protein, such as bait or prey, is influenced by the mass of the protein in two-hybrid assays. Due to no fundamental distinction between the bain and the prey in these assays the result may be reflective of the experiment setup. The area of the violin corresponds the number of observation in each group (legend on the left). \"not two-hybrid, AP-MS\" tab clearly show that AP-MS techniques identify many preys per single bait (the issue was discussed in the introduction)." }
bait_vs_non_bait = copy(all.IntAct[,.(IDs_interactor_A, IDs_interactor_B, Taxid_interactor_A, Taxid_interactor_B, bait_prey_status_A,bait_prey_status_B,interactor_IDs_databases_A,interactor_IDs_databases_B)])
proteome_vs_imex_details_f = as.data.table(proteome_vs_imex_interaction_details_all) # filterin datasets: Publication_Identifiers != "25416956"

# Length for interactor A, implicit filtering: proteins only and species human due to the data.frame "proteome_vs_imex_details_f" contents
bait_vs_non_bait = merge(bait_vs_non_bait, proteome_vs_imex_details_f[, .(whole_proteome_IDs, Mass, two_hybrid_vs_AP_MS, SPECIES_NAME)], by.x = "IDs_interactor_A", by.y = "whole_proteome_IDs", all.y = F, all.x = F)
# Length for interactor B, implicit filtering: proteins only and species human due to the data.frame "proteome_vs_imex_details_f" contents
bait_vs_non_bait = merge(bait_vs_non_bait, proteome_vs_imex_details_f[, .(whole_proteome_IDs, Mass, two_hybrid_vs_AP_MS, SPECIES_NAME)], by.x = "IDs_interactor_B", by.y = "whole_proteome_IDs", all.y = F, all.x = F)
# interactions to interactors
bait_vs_non_bait = bait_vs_non_bait[, data.table(IDs_interactor = c(IDs_interactor_A, IDs_interactor_B), 
                                                 bait_prey_status = as.character(c(bait_prey_status_A,bait_prey_status_B)),
                                                 Mass = c(Mass.x, Mass.y),
                                                 interactor_IDs_databases = c(interactor_IDs_databases_A,
                                                                              interactor_IDs_databases_B),
                                                 two_hybrid_vs_AP_MS = as.character(two_hybrid_vs_AP_MS.x, two_hybrid_vs_AP_MS.y),
                                                 SPECIES_NAME = c(SPECIES_NAME.x,SPECIES_NAME.y))]
bait_vs_non_bait = unique(bait_vs_non_bait)
# getting bait-prey status to separate columns: spreading data.table
# bait_vs_non_bait = dcast(bait_vs_non_bait, IDs_interactor + Mass + interactor_IDs_databases ~ bait_prey_status, value.var = "bait_prey_status",fill ="") # too many experimental role types for combinations
bait_vs_non_bait[,median_log10_mass_per_role := median(log10(Mass)), by = .(bait_prey_status,two_hybrid_vs_AP_MS,SPECIES_NAME)]
bait_vs_non_bait[,N_bait_prey_status := .N, by = .(bait_prey_status, SPECIES_NAME)]
bait_vs_non_bait[,bait_prey_status_label := paste(bait_prey_status,", N =", N_bait_prey_status)]

bait_vs_non_bait = bait_vs_non_bait[N_bait_prey_status > 1000,]
ggplot(bait_vs_non_bait[two_hybrid_vs_AP_MS != "not in IntAct" & SPECIES_NAME == "Homo sapiens",], aes(y = Mass, x = bait_prey_status,fill = bait_prey_status_label)) +geom_violin(draw_quantiles = c(0.05,0.25,0.495,0.5,0.505,0.75,0.95),scale = "count")  + theme(strip.text.y = element_text(angle = 0)) +xlab("protein mass, Da, log10 scale") + ggtitle("the distribution density of protein mass grouped by experimental role and detection method \n (for proteins in IMEx)") +#geom_hline(aes(yintercept = 10^median_log10_mass_per_role, color = bait_prey_status_label))+
  facet_grid(SPECIES_NAME~two_hybrid_vs_AP_MS)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))+theme(axis.text.x = element_text(angle =-35))
```
 
   Evidently, the experimental role of a protein is influenced by the protein length in two-hybrid methods: prey proteins tend to be longer than bait proteins. Two hybrid bait and prey are not fundamentally different. In two-hybrid methods, bait protein and prey protein can be cloned into either of the plasmids used in the assay, in contrast, AP-MS aproaches use antibodies targeting the bait to purify the bait and any protein interacting with it, this way, pray proteins don't need to be cloned the assay to work, now cloning restriction applies. So the distinction observed is not descriptiptive of protein as much as it is of the experimental setup. Potential explanation might be that fragments of proteins (aimed to identify sufficient to bind regions) are often cloned as a bait. This bias might also be created by a specific high-throughput two-hybrid study.  

# Conclusions

Our analysis shows that main model species have interaction data for the substantial fraction of the proteome. It also suggests that interaction data is still biased [@Rolland:2014aa] towards well-researched proteins. We can also see that interaction detection methods have specific biases; however, we were don't see many of the effects from the original study on structural bias published 8 years ago[@Bjorklund:2008aa]. The latter supports the take-home-message of that paper: aggregated datasets of protein interactions represent a more robust source for drawing conclusions. Large fraction of IntAct proteins are also present in BioGRID which combined with the result of functional enrichment suggest that the bias we see in the coverage comes the fact that some categories proteins are underresearched and not from the undercuration by IntAct or BioGRID teams. Finally, our result suggests that all experimental resources (human interaction data only) have similar bias to biological process, molecular function or the cellular localisation of the proteins; however, STRING database, which includes computational prediction data, is the least biased.  
Result of this study have served as a foundation to a data integration project aimed use multiple protein-protein interaction resources and machine learning to find publications which contain protein-protein interactions not yet curated into IntAct database. This project has a potential to reduce bias in the interaction data, increase accessibility of currectly published protein-protein interactions involving proteins with underrepresented functions and in currently in progress [@PPorras2017].

# Supplementary figures

## Supplementary figure 1 

```{r Supplementary1_IMEx_vs_Uniprot_venndiagram_all_Uniprot, cache=F, fig.width=8, fig.height=8, fig.cap="Supplementary figure 1. The overlap between proteins with known interactions (interactome) and all proteins included in UniprotKB (proteome). Red circles represent proteins which have interacting partners curated in IntAct, blue circles represent proteins in SwissProt, taking into account isoforms (left) or canonical identifiers (right)."}
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
{
  if(file.exists(filename.summary.all)) proteome_vs_interactome_summary.all = fread(filename.summary.all, sep = "\t", stringsAsFactors = F, data.table = F)
}
## Plotting with venn.diagram - Uniprot vs IMEx (or IntAct)
# code to be modified for different graphs
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
reviewed_venn = 1                 # 1 or 2
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
proteome_vs_interactome_summary.all$species.name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", proteome_vs_interactome_summary.all$species.name)
proteome_vs_interactome_summary.all$species.name = gsub("strain K12", "Escherichia coli, strain K12", proteome_vs_interactome_summary.all$species.name)
SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", SPECIES_NAME)
SPECIES_NAME = gsub("strain K12", "Escherichia coli, strain K12", SPECIES_NAME)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == TRUE)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, database == IMExdatabase)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, database == IMExdatabase)

library(VennDiagram)
{
grid.newpage()

if(reviewed_venn == 2){plotname = paste0("Proteome (SwissProt) coverage by interaction databases(",IMExdatabase,")")
databasename = "SwissProt"}
if(reviewed_venn == 1){plotname = paste0("Proteome (all UniprotKB) coverage by interaction databases(",IMExdatabase,")")
databasename = "UniprotKB"}

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("isoforms included", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
}
popViewport()
}
```

## Supplementary figure 2

```{r Supplementary2_BioGRID_vs_IMEx_vs_Uniprot_N_Uniprot_Species, cache=F, fig.width=8, fig.height=8, fig.cap="Supplementary figure 2. The number of interacting proteins from given species or the other species in BioGRID. Red bar shows the number of proteins from a given species, blue bar shows the number of proteins from another species. Red group proteins form interactions both with red and blue group proteins, blue group proteins form interactions only with red group proteins." }
### combine the summaries for multiple species of how many interactors have non-uniprot identifiers
interactome_identifiers_summary.all = data.frame()
for (i in isoforms) {
  for(n in SPECIES_NAME) {
    filename.summary = paste("./summaries/","uniprotKB_IDs_and_",n,"_biogrid_from_mentha_interactors_summary", "_isoforms_",i,"_", date,".txt", sep = "")
    if(!file.exists(filename.summary)) {
      interactome_identifiers_summary.all
    }
    if(file.exists(filename.summary)) {
      interactome_identifiers_summary.o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
      interactome_identifiers_summary.all = rbind(interactome_identifiers_summary.all, interactome_identifiers_summary.o)
    }
  }
}
interactome_identifiers_summary.all = unique(interactome_identifiers_summary.all)
## save all species summary
filename.summary.all = paste("./results/","interactome_identifiers_BioGRID_summary_",date,".txt", sep = "")
write.table(interactome_identifiers_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)

#################
interactome_identifiers_summary.all.s = interactome_identifiers_summary.all[,c(3,4,5,6,7)]
## Transform table for plotting with ggplot2
library(reshape2)
interactome_identifiers_summary.all.s.m= melt(data = interactome_identifiers_summary.all.s,
                                              id.vars = c("SPECIES_NAME", "SPECIES_ID"),
                                              variable.name = "decription",
                                              value.name = "number")
interactome_identifiers_summary.all.s.m=unique(interactome_identifiers_summary.all.s.m)
## rename yeast and E.coli
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain K12", "E. coli, strain K12", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Caenorhabditis elegans", "C. elegans", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Drosophila melanogaster", "D. melanogaster", interactome_identifiers_summary.all.s.m$SPECIES_NAME)

# filter out non-uniprot identifiers to make picture clearer
interactome_identifiers_summary.all.s.m$decription = gsub("\\.", " ", interactome_identifiers_summary.all.s.m$decription)
ind = interactome_identifiers_summary.all.s.m$decription != "interacting partners with the other identifier"
interactome_identifiers_summary.all.s.m = interactome_identifiers_summary.all.s.m[ind,]

# plot
library(ggplot2)
library(dplyr)

proteome_vs_interactome_plot <- ggplot(interactome_identifiers_summary.all.s.m, aes(x=SPECIES_NAME, y=number, fill=decription,label=number)) + geom_bar(width = 0.9, stat = "identity", position = "stack") + geom_label(position = "stack", size = 4, label.padding = unit(0.08, "lines")) +
  ggtitle("The number of interacting partners which have UniprotKB identifiers \n and belong to the species of interest") + theme(axis.text.x=element_text(angle = 20), axis.title.x = element_text(size = 0)) + ylab("number of proteins")
proteome_vs_interactome_plot
# save plot
# filename=paste("./results/", "interactome_identifiers_summary_plot_SMALL",date,".png", sep = "")
# ggsave(filename, proteome_vs_interactome_plot, width = 12, height = 12)

### ======================================================================== ###

```

## Supplementary figure 3 

```{r Supplementary3_protein_mass_distribution_qqplot, fig.width=8, fig.height=8, fig.cap="Supplementary figure 3. Proteomes have much more long proteins than normal distribution would predict (proteins, dots, are above the line in qq-plot). The distribution of logarhithm base 10 of protein mass is approximately normal. In this plot the distribution of the data is plotted against the normal distribution. If dots fall below the curve of the left or above the curve on the right this would suggest that normal distribution underpredict the number of extreme values which will skew the result of parametric statistical test."}

SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
      proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)
      proteome_vs_imex_details_f_minus_odor = proteome_vs_imex_details_f[-grep("Odor", 
                                                                                proteome_vs_imex_details_f$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf = proteome_vs_imex_details_f_minus_odor[-grep("Olfactory",
                                                                                              proteome_vs_imex_details_f_minus_odor$Protein.names),]
      SwissProt_not_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
                 ## is the distibution of mass or log(mass) normal?
      library(rafalib)
      mypar(2,2)
      popsd(log10(SwissProt_not_IMEX))
      median(log10(SwissProt_not_IMEX))
      mad(log10(SwissProt_not_IMEX))
      {
      qqnorm(log10(SwissProt_not_IMEX), main = "SwissProt_not_IMEX, log(protein mass)")
      qqline(log10(SwissProt_not_IMEX))
      qqnorm(log10(SwissProt_and_IMEX), main = "SwissProt_and_IMEX, log(protein mass)")
      qqline(log10(SwissProt_and_IMEX))
      qqnorm((SwissProt_not_IMEX), main = "SwissProt_not_IMEX, protein mass")
      qqline((SwissProt_not_IMEX))
      qqnorm((SwissProt_and_IMEX), main = "SwissProt_and_IMEX, protein mass")
      qqline((SwissProt_and_IMEX))
      }

            ## it indeed is
      
```

## Supplementary figure 4

```{r protein_length_det_method_rlm,  fig.width = 10, fig.height = 8, fig.cap= "Supplementary figure 4. The results of statistical tests can be visualised on a plot. In the box plot below, each vertical arrow points to the median mass of the proteins in a particular group. The middle line of the boxplot represents a median which happens to coincide with mean because the distribution of logarithm base 10 of mass is approximately normally distributed. Each yellow arrow shows the p-value and the difference in protein mass between two corresponding groups."}
library(rafalib)
library(MASS)
library(RColorBrewer)
library(multcomp)
# read the table saved before 
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
proteome_vs_imex_interaction_details_all = data.table()
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_interaction_details_f = as.data.table(fread(filename, header = T, stringsAsFactors = F,quote="", data.table = F))
n = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", n)
n = gsub("strain K12", "Escherichia coli, strain K12", n)
proteome_vs_imex_interaction_details_f[ , c("SPECIES_NAME","reviewed","isoforms", "SPECIES_ID") := list(n,r,i,SPECIES_ID)]
proteome_vs_imex_interaction_details_all = rbind(proteome_vs_imex_interaction_details_all,proteome_vs_imex_interaction_details_f, fill =T)
    }}}

proteome_vs_imex_interaction_details_all$two_hybrid_vs_AP_MS = factor(proteome_vs_imex_interaction_details_all$two_hybrid_vs_AP_MS, levels = c("not in IntAct", "not two-hybrid, and not AP-MS", "two-hybrid, not AP-MS", "not two-hybrid, AP-MS", "two-hybrid and AP-MS"))

proteome_vs_imex_interaction_details_all[, Median_mass := median((Mass)), by = .(SPECIES_NAME,two_hybrid_vs_AP_MS)]

proteome_vs_imex_interaction_details_all[,plot_labels := (paste0(gsub("_"," ",two_hybrid_vs_AP_MS),", (median mass: ", signif(Median_mass/1000,3)," kDa)"))]
proteome_vs_imex_interaction_details_all[,plot_labels := (paste0(signif(Median_mass/1000,3)," kDa)"))]
## linear model code below
# ============================================

# IMEx_two_hybrid_AP_MS
mypar(2,2)
for(sp in SPECIES_NAME){
sp = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", sp)
sp = gsub("strain K12", "Escherichia coli, strain K12", sp)
data = proteome_vs_imex_interaction_details_all[two_hybrid_vs_AP_MS != "not in IntAct" & SPECIES_NAME == sp,]
# two_hybrid_vs_AP_MS was previously set up as factor with 5 levels - now we need to relevel + keep alphabetic ordering for plotting 
data[, two_hybrid_vs_AP_MS := as.character(two_hybrid_vs_AP_MS)]
fit_rlm = rlm(log10(Mass)~two_hybrid_vs_AP_MS, data = data)
coefs <- coef(fit_rlm)
names(coefs) = data[,sort(unique(two_hybrid_vs_AP_MS))]

## Visual explanation
a <- -0.25
lgth <- .1
cols <- brewer.pal(8,"Dark2")

boxplot(log10(Mass)~two_hybrid_vs_AP_MS, data = data, 
           vertical=TRUE, pch=1, method="jitter",las=1,cex.axis= 0.58, main = paste0(sp, ": protein length vs interaction detmethod, rlm"), cex.main=0.99)
abline(h=0)
arrows(1+a,0,1+a,coefs[1],lwd=3,col=cols[1],length=lgth)
abline(h=coefs[1],col=cols[1])
#AP_MS
arrows(2+a,coefs[1],2+a,coefs[1]+coefs[2],lwd=3,col=cols[2],length=lgth)
segments(2+2*a,coefs[1]+coefs[2],2-2*a,coefs[1]+coefs[2],col=cols[2])
#two-hybrid and #AP_MS
arrows(3+a,coefs[1],3+a,coefs[1]+coefs[3],lwd=3,col=cols[3],length=lgth)
segments(3+2*a,coefs[1]+coefs[3],3-2*a,coefs[1]+coefs[3],col=cols[2])
#two-hybrid
arrows(4+a,coefs[1],4+a,coefs[1]+coefs[4],lwd=3,col=cols[4],length=lgth)
segments(4+2*a,coefs[1]+coefs[4],4-2*a,coefs[1]+coefs[4],col=cols[2])

# two_hybrid vs AP_MS significance testing
C <- matrix(c(0,1,0,-1),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[2] - coefs[4])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[1]+coefs[2]
estimate_2 = coefs[1]+coefs[4]
arrows(2,estimate_1-0.3,4,estimate_2-0.3,lwd=3,col=cols[6],length=lgth)
text(3,(estimate_1-0.35 + estimate_2-0.35)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# two_hybrid vs AP_MS_and_two_hybrid significance testing
C <- matrix(c(0,0,1,-1),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[3] - coefs[4])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[1]+coefs[3]
estimate_2 = coefs[1]+coefs[4]
arrows(3,estimate_1+0.3,4,estimate_2+0.3,lwd=3,col=cols[6],length=lgth)
text(3.5,(estimate_1+0.35 + estimate_2+0.35)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# other_methods vs AP_MS significance testing
C <- matrix(c(0,1,0,0),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[2])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[2]+coefs[1]
estimate_2 = coefs[1]
arrows(2,estimate_1-0.4,1,estimate_2-0.4,lwd=3,col=cols[6],length=lgth)
text(1.5,(estimate_1-0.45 + estimate_2-0.45)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# other_methods vs AP_MS_and_two_hybrid significance testing
C <- matrix(c(0,0,1,0),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[3])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[3]+coefs[1]
estimate_2 = coefs[1]
arrows(3,estimate_1+0.4,1,estimate_2+0.4,lwd=3,col=cols[6],length=lgth)
text(2.5,(estimate_1+0.45 + estimate_2+0.45)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# AP_MS vs AP_MS_and_two_hybrid significance testing
C <- matrix(c(0,-1,1,0),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[3]-coefs[2])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[3]+coefs[1]
estimate_2 = coefs[1]+coefs[2]
arrows(3,estimate_1+0.7,2,estimate_2+0.7,lwd=3,col=cols[6],length=lgth)
text(2.5,(estimate_1+0.75 + estimate_2+0.75)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)

legend("topright",names(coefs),fill=cols,cex=.75,bg="white")
}
```
