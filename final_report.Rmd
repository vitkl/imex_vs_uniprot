--- 
title: Characterisation of model species interactome available from 
  primary molecular interaction databases 
author: "Vitalii Kleshchevnikov" 
date: "21 December 2016" 
output: html_document 
--- 
 
```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = FALSE, results = "hide", warning = FALSE, message = FALSE, fig.keep = "all") 
``` 

The report was published on `r Sys.Date()`

# Outline

1. Abstract
2. Introduction
3. Methods
4. Results and discussion
    - how available interactome covers the proteome
    - IMEx(IntAct) vs Biogrid
    - which proteins are missing
    - do intrinsically disordered proteins have more interactions?
    - interaction detection biases
    - proteins well researched but not present in IntAct
5. Conclusion  

# Abstract


# Introduction 
 
The structure and the function of the cell arise from interactions between molecules inside and outside it. Though proteins, nucleic acids, lipids and small molecules can all form important interactions, studies and literature focus mainly on interactions between proteins and other macromolecules. We can discover and study these molecular interactions using a number of experimental and computational techniques. This study focuses on molecular interactions identified in the experimental setting, most of which are represented in the literature and databases by protein-protein interactions (also protein-DNA interactions obtained, for example, by ChIP-Seq, but those are traditionally incorporated into genomic databases).  
 
Due to the nature of detection methods used, interactions come in two flavors: binary interactions and associations. Binary interactions are the interactions between two components, for example, two specific proteins, some detection methods (e.g. two-hybrid) identify those. To understand associations, we need to imagine we know proteins A, B and C constitute a complex and interact as shown in a figure 1 A. When we conduct an experiment, we choose the bait (the molecule experimentally treated to capture its interacting partners - called preys) to be protein A, and by detection method (e.g. affinity-purification mass spectrometry) we get both protein B and protein C detected as preys. Next step is to translate bait-prey relationship into a model of reality like the one shown in the figure 1 A. We call interactions between A-B and A-C associations because we cannot infer the true relationship between A, B, and C from this experiment design. In the other words, establishing that proteins are in direct physical contact is really challenging. However, to represent associations in a tabular format with each row corresponding to one interaction (e.g. A-B) we need to expand those. Two ways are commonly used to expand interactions, hub and spoke expansion, both shown in the figure 1 B. 

#### Defining interactome

The aggregation of all components and their interactions into a single network result in what we call interactome, the whole of all molecular interactions. You can also look into the subset of this network, for example, you can select only proteins, only those proteins that are expressed in the brain, and only the interactions between this protein identified experimentally in the brain cells. This example reflects the complexity and the diversity of the interactome - which is what you would expect from a system underlying the complexity and the diversity of the cell types, cellular behaviors, and functions. For the same reason, only by studying these interactions and how they change in specific cell types and under specific circumstances in combination with the functional analysis we can decipher cellular regulatory networks. The ultimate goal of the research in the field would be to capture all physical interactions and thoroughly describe them while avoiding false discoveries. 

#### Experimental approaches for discovering interactions

Experimental protein interaction detection methods can be classified into 3 main categories based on the evidence they provide and whether they can be used in a high-throughput manner:
The first category is formed by methods using affinity purification of the bait and all the prey associated with it. Following that, preys can be identified using western-blotting and specific antibodies or using mass-spectrometry, which can be done in a high-throughput manner [Mann, ]. The main advantage of these methods is the ability to quantitatively characterize interactions [Mann, ] and capture many prey proteins per bait - the latter, however, presents the disadvantage of dealing with associations. The main disadvantage of these techniques is that for the reliable result it requires all interacting proteins to be soluble []. 
The second category is formed by protein complementation techniques which include two-hybrid (transcription factor complementation), the most widely used interaction detection method (including high-throughput experiments). In this method, pairs of proteins are tested for interaction and therefore all discovered interactions are binary (the main advantage of this method). Classic implementation of two-hybrid requires proteins to be soluble as well [], however, two-hybrid for membrane proteins was also developed []. The main disadvantage of two-hybrid methods are that they allow only qualitative characterisation of interactions [], are usually performed in yeast (thus, have a lower sensitivity) and are highly prone to false-positive results [].
Final category consists of methods based on the structure of the protein complex. They can provide valuable information on how exactly physical interaction occurs but as for now are extremely labor-intensive and will always need complementary experiments showing if the proteins actually interact in the cellular context.

#### Challenges of interactomics

Four big challenges substantially complicate the study of molecular interactions, especially on the whole organism scale. The first being that we don't know the true nature of underlying our experimental results (all assays provide evidence that interaction is possible and some can provide quantitative description, but all are prone to error and the problem described in the figure 1 A) which lead to the necessity of combining interaction data from multiple experiments and complex statistical evaluation of how probable the interaction is based on that data (Bayesian approach [1]) rather than receiving confident yes-or-no result from single experiment. Interaction databases make an effort to score the interactions based on supporting evidence, however, this is usually done with non-probabilistic heuristic approaches, like MI score [PMCID: PMC4316181]. 

The second big challenge is the problem of "noise" - or false positives. Different interaction detection experiments are prone to these errors for different reasons, for example, in-vitro experiments (e.g. TAP-MS) may allow the interaction between proteins which are normally included in separate cellular compartments. Specific groups of proteins (based on their physical or chemical properties) may have a higher susceptibility to false positives, for example, intermediate filaments (e.g. nuclear lamins) have low solubility under non-denaturing conditions necessary for affinity-purification based techniques, which may lead to artifactual results. However plausible, this particular problem lacks empirical evidence and requires more investigation. A more general problem of noise will be adressed by more proteome-scale interactomics experiments (which can include enough samples to guarantee low false positive rate while still identifying interactions).

The third big challenge is that our knowledge of interactome is incomplete and arises from the fact that experimental approaches have low statistical power and often miss out some real interactions. Also, many proteins, especially for non-popular model species, were not researched for protein interactions.

The final challenge contributes to the "incomplete interactome" problem but is grounded in the fact that not all protein interaction discovered and published are included in protein interaction databases. In the other words, this is database curation problem. More than 100 public databases containing protein interactions are available now. These databases differ:
- by the types of data they include (e.g. computational prediction, manual curation from experimental articles - primary, aggregated data from many primary databases - secondary),  
- the level of detail captured from articles to describe interactions,  
- how often and if they are updated with new data.  
The level of detail ranges from only mentioning the pairs of interactors and heuristic score assigned to them (STRING, updated once in 2 years) to the ones containing experiment details (detection method, bait/prey status, if available - quantitative data, experiment setup, protein variants), such as IntAct [PMCID: PMC3703241]. 
The amounts of interaction data generated per year is growing exponentially making manual curation of all this data into primary databases a daunting task. To prioritise curation efforts and reduce redundancy between databases (to curate different data using the same standards) IMEx consortium was formed in 2012 [PMCID: PMC3703241]. IMEx-compliant databases include all big primary databases excluding only BioGRID (which curates at the lower level of detail) and not active legacy databases.

#### Motivation for this study

Solving some of these challenges may be easier than the others. In particular, to solve the last challenge we can prioritize curation efforts for already published interactions to cover unrepresented proteins and we can encourage authors to submit their results to the databases prior to publishing. We can also encourage research of underrepresented parts of the interactome. However, for both of those aims, we need to characterize the interactome already present in interaction databases. Specifically, to learn how available interactome covers the proteome of main model species, if there are any biases to proteins with no available interactions and if any major protein interaction detection methods exhibit any biases towards specific groups of proteins. 
The other helpful to look at the problem is to search for underrepresented in interaction databases but in general well-researched proteins.

# Aims of the study

1. Find out how available interactome covers the proteome of main model species. Considering either all UniProtKB or SwissProt entries only as the proteome (canonical identifiers as well as protein isoforms). Consider all interactions from IMEx-compliant databases as interactome.  
2. Compare the coverage of proteome by interactome from IMEx to the interactome from BioGRID (the other major primary database).

3. Find out if proteins with no available interactions stand out by specific functions (Gene Ontology, GO: biological process and molecular function), cellular localization (GO), molecular mass, or protein evidence status from SwissProt

4. Are proteins with high fraction of intrinsically disordered domains more likely to have interactions available and do they have more interactions (if normalized for how well-studied proteins are?

4. Find out if major protein interaction detection methods (two-hybrid and AP-MS, AP-WB?) exhibit any bias towards biochemical properties of the proteins involved (mass, disordered regions, hydropathy, the fraction of charged residues)

### 5. Find out if there are any proteins which are in general well researched (many associated publications or manual GO annotations) but underrepresented in IntAct (low MI score)
5. What is the relationship between the number of interactions or MI score and the number of publicationions or GO terms per protein?

6. If that is possible to measure: do intermediate filaments (or other highly insoluble proteins) really have higher rates of false-discovered interactions?

# Methods - data processing and analysis

### Getting proteome from UniProtKB

Whole proteome (all UniProtKB) for each species was downloaded programmatically in R using UniProt rest API. SwissProt-proteome was subset from whole proteome by reviewed status column. UniProt identifies proteins by UniProtKB/AC (e.g. P04637, accession) which does not distinguish between protein isoforms. UniProt aggregates isoform information and identifiers (e.g. P04637-4) in a separate column with zero to many isoforms per each UniProtKB accession. To generate proteome list which includes protein isoforms, isoform accessions were extracted and combined with the list of generic accessions. In this analysis, protein evidence status and protein mass are only attributed to generic accessions. 

### Getting and transforming interactome data from IMEx databases and BioGRID

Interactome from all IMEx databases was downloaded programmatically in R using PSIQUIC package from Bioconductor [Paul Shannon (2015). PSICQUIC]. IMEx databases include IntAct, MINT, bhf-ucl, MPIDB, MatrixDB, HPIDb, I2D-IMEx, InnateDB-IMEx, MolCon, UniProt, MBInfo. The list of interactions (pairs of interactors) was transformed into the list of interactors preserving interactor identifiers, the type of interactor identifier, species information and the database interaction originates from. Only unique proteins wereIMEx databases contain interactions between proteins, RNA, DNA and small molecules, moreover, these interaction may involve molecules originating from different species. Therefore, to perform by species interactome/proteome comparison there is a need to remove non-UniProtKB/AC molecule identifiers (which removes non-protein molecules, although, may also remove small fraction of proteins which have no UniprotKB/AC) and there is a need to remove proteins originating from other species. Also, entries in IMEx databases has to be cleaned of tags and textual descriptions ("taxid:9606(human-h1299)|taxid:9606(Homo sapiens lung lymph node carcinoma)" to "9606") to make further analysis easier and cleaner.
Next, when provided in the research articles protein isoform information is always included in IMEx databases, so to perform analysis excluding isoform information UniProtKB/AC were cleaned of -N suffix (P04637-4 to P04637).


### Disordered regions and biochemical properties
### Gene ontology enrichment analysis

```{r IMEx_vs_Uniprot_processing, cache=F}

SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")

date = Sys.Date()
## Please specify the date for which you want to perform analysis (if not today)
date = as.Date("2017-01-06")

## ## Use all Uniprot if reviewed == 1, only Swissprot data if reviewed == 2, 
## ## TrEMBL data if reviewed == 3
reviewed = c(1, 2)

## ## Distinguish between isoforms or use only generic Uniprot IDs: TRUE / FALSE?
isoforms = c(TRUE, FALSE)

## missing_proteins = TRUE => proteins missing protein evidence are shown
## missing_proteins = FALSE => proteins for which protein evidence exists are shown
missing_proteins = TRUE

## The code below queries databases, saves and processes results, 
## gives summary on how many interactors have Uniprot IDs or belong to the SPECIES_NAME
## generates table with 0 and 1 for the combination of SPECIES_NAME, reviewed, isoforms
source("intact_vs_uniprot.R")
for (i in isoforms) {
  for (r in reviewed) {
    for (n in SPECIES_NAME) {
      intact_vs_uniprot(SPECIES_NAME = n, reviewed = r, isoforms = i, missing_proteins = TRUE, date = date)
      message(paste("- ",n," -  reviewed", r, " -  isoforms included", i))
    }
  }
}

## The code below does overlap comparisons and saves summaries
source("intact_vs_uniprot_overlap.R")
source("SPECIES_NAME_TO_ID.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      intact_vs_uniprot_overlap(SPECIES_NAME = n, SPECIES_ID = SPECIES_ID, reviewed = r, isoforms = i, date)
      message(paste("- ",n," -  reviewed", r, " -  isoforms included", i))
    }
  }
}

### combine the summaries for multiple species
proteome_vs_interactome_summary.all = data.frame()
whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all = data.frame()
whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all = data.frame()
for (r in reviewed) {
  for (i in isoforms) {
    for(n in SPECIES_NAME) {
      #=====================================
      filename.summary = paste("./summaries/","proteome_vs_interactome_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary)) {
        proteome_vs_interactome_summary.all
      }
      if(file.exists(filename.summary)) {
        proteome_vs_interactome_summary_o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
        proteome_vs_interactome_summary.all = rbind(proteome_vs_interactome_summary.all, proteome_vs_interactome_summary_o)
      }
      #=====================================
      filename.summary2 = paste("./summaries/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary2)) {
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all
      }
      if(file.exists(filename.summary2)) {
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist = as.data.frame(read.delim(filename.summary2, stringsAsFactors = F))
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all = rbind(whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all, whole_proteome_Uniprot_vs_IMEx_vs_protein.exist)
      }
      #=====================================
      filename.summary3 = paste("./summaries/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary3)) {
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all
      }
      if(file.exists(filename.summary3)) {
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist = as.data.frame(read.delim(filename.summary3, stringsAsFactors = F))
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all = rbind(whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all, whole_proteome_Uniprot_vs_IntAct_vs_protein.exist)
      }
  }
}
}
## save all species summary
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
write.table(proteome_vs_interactome_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)
filename.summary.all2 = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",date,".txt", sep = "")
write.table(whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all, filename.summary.all2, col.names=T,row.names=F,sep="\t",quote=F)
filename.summary.all3 = paste("./results/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",date,".txt", sep = "")
write.table(whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all, filename.summary.all3, col.names=T,row.names=F,sep="\t",quote=F)

### combine the summaries for multiple species of how many interactors have non-uniprot and non-given-species identifiers
interactome_identifiers_summary.all = data.frame()
  for (i in isoforms) {
    for(n in SPECIES_NAME) {
      filename.summary = paste("./summaries/","uniprotKB_IDs_and_",n,"_interactors_summary_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary)) {
        interactome_identifiers_summary.all
      }
      if(file.exists(filename.summary)) {
        interactome_identifiers_summary.o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
        interactome_identifiers_summary.all = rbind(interactome_identifiers_summary.all, interactome_identifiers_summary.o)
      }
    }
  }
interactome_identifiers_summary.all = unique(interactome_identifiers_summary.all)
## save all species summary
filename.summary.all = paste("./results/","interactome_identifiers_summary_",date,".txt", sep = "")
write.table(interactome_identifiers_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)

## Plotting the number of interactors which have UniprotKB identifiers and belong to the species queried
interactome_identifiers_summary.all.s = interactome_identifiers_summary.all[,c(3,4,5,6,7)]
## Transform table for plotting with ggplot2
library(reshape2)
interactome_identifiers_summary.all.s.m= melt(data = interactome_identifiers_summary.all.s,
                                              id.vars = c("SPECIES_NAME", "SPECIES_ID"),
                                              variable.name = "decription",
                                              value.name = "number")
## rename yeast and E.coli
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain K12", "E. coli, strain K12", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Caenorhabditis elegans", "C. elegans", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Drosophila melanogaster", "D. melanogaster", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
```

# Results

## how well available interactome covers the proteome

### Available interactome covers substantial fraction of the reviewed proteome of main model species

```{r IMEx_vs_Uniprot_venndiagram, cache=F, fig.width=8, fig.height=8, fig.cap="Figure 2"}
## Plotting with venn.diagram - Uniprot vs IMEx (or IntAct)
# code to be modified for different graphs
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
reviewed_venn = 2                 # 1 or 2
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
proteome_vs_interactome_summary.all$species.name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", proteome_vs_interactome_summary.all$species.name)
proteome_vs_interactome_summary.all$species.name = gsub("strain K12", "Escherichia coli, strain K12", proteome_vs_interactome_summary.all$species.name)
SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", SPECIES_NAME)
SPECIES_NAME = gsub("strain K12", "Escherichia coli, strain K12", SPECIES_NAME)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == TRUE)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, database == IMExdatabase)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, database == IMExdatabase)

library(VennDiagram)
{
grid.newpage()

if(reviewed_venn == 2){plotname = paste0("Proteome (SwissProt) coverage by interaction databases(",IMExdatabase,")")
databasename = "SwissProt"}
if(reviewed_venn == 1){plotname = paste0("Proteome (all UniprotKB) coverage by interaction databases(",IMExdatabase,")")
databasename = "UniprotKB"}

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("isoforms included", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
}
popViewport()
}
```

Overall - the best interactome annotated by IMEx databases is baker’s yeast, 2nd best interactome is *E.coli*. All other interactomes cover less than the half of their respective proteome (all UniprotKB, supplementary figure 1). Overlap between the interactome and reviewed proteome (SwissProt) looks much better. A large fraction of human, mouse, arabidopsis proteins-interactors and more than a half of drosophila and *C.elegans* proteins-interactors are absent in SwissProt – under-annotation by Uniprot. 
Protein isoforms (in multicellular model organisms) are almost not annotated in the interactome. Human is the exception – 2452 protein isoforms out of 21957. For most organisms in this list (with the exception of mouse) IntAct overlaps to a large extent with the other IMEx databases (supplementary figure 1).

### Mouse and human proteins are commonly combined for interaction experiments

The fact that researchers tend to put proteins from other species (mostly human) into mouse experiments or tend to put mouse proteins into cell from other species (mostly human) is also common for interaction detection experiments and is clearly seen in the figure 3: half of the mouse interactors are from the other species. This holds true both for IMEx databases (figure 3) and for BioGRID. However, this analysis doesn't show which proteins (mouse or human) where used as bait to capture interactions in which cells (mouse or human).

Figure 3 also displays how many interactors do not have Uniprot indentifiers - those are small molecules, RNA, DNA or a small fraction of proteins not mapped to Uniprot. Big fraction of *C.elegans* interactors are coming from single experiment mapping trascrition factors to their sites []

```{r IMEx_vs_Uniprot_N_Uniprot&Species, cache=F, fig.width=8, fig.height=8, fig.cap="Figure 3" }
# plot how many interactors have non-uniprot and non-given-species identifiers
library(ggplot2)
library(dplyr)
proteome_vs_interactome_plot <- ggplot(interactome_identifiers_summary.all.s.m, aes(x=SPECIES_NAME, y=number, fill=decription)) + geom_bar(width = 0.9, stat = "identity", position = "stack") + geom_label(aes(label=number), position = "stack", size = 4, label.padding = unit(0.08, "lines")) +
  ggtitle("The number of interacting molecules (interactors) which have UniprotKB identifiers \n and belong to the species of interest") + theme(axis.text.x=element_text(angle = 20), axis.title.x = element_text(size = 0)) + ylab("number of proteins")
proteome_vs_interactome_plot
# save plot
# filename=paste("./results/", "interactome_identifiers_summary_plot_SMALL",date,".png", sep = "")
# ggsave(filename, proteome_vs_interactome_plot, width = 12, height = 12)
```

Interchangable use of mouse and human proteins generates interaction data which is extremely hard to reuse due to the fact that it requires mapping between homologous proteins. However, this may not be the biggest problem with studying the interactions between mouse and human proteins and trying to correctly intrepret results. Recent studies of intrinsically disordered proteins show that linear amino acid motifs located in disordered regions frequently mediate protein-protein interactions [], for example, disordered region of p53 mediates its ability to recruit transcription-activating proteins to the promoter []. More importantily, these linear amino acid motifs can evolve quickly, for example, allowing cancer cells to escape control by P53 []. So, while the interaction between mouse protein A and human protein B can exist, that might not be true for the interaction bewteen human protein A and human protein B, and vice-verse.

```{r dowlnload_all_IntAct, cache=F, fig.width=8}
# IntAct FTP contains the following databases = c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
#               "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")
# this will take time and data traffic ~ 2.5GB

url_intact = "ftp://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.txt"
filename_intact = paste0("./Data/IntAct_MITAB27_release_", format(Sys.Date(), "%m-%Y.txt"))
if(!file.exists(filename_intact)) {
  downloader::download(url_intact, filename_intact)
  gitignore = c(substr(filename_intact, 2, nchar(filename_intact)), readLines(".gitignore"))
  write(gitignore, ".gitignore")
  }
# Read all IntAct - do not attemp without 2.5 GB of free RAM
library(data.table)
all.IntAct = fread(filename_intact)
# changing column names to data.table-compatible format
{
(colnames_IntAct = colnames(all.IntAct))
colnames(all.IntAct) = gsub(" ","_",colnames(all.IntAct))
colnames(all.IntAct) = gsub("\\(|\\)","",colnames(all.IntAct))
colnames(all.IntAct) = gsub("#","",colnames(all.IntAct))
}
# cleaning Taxid "taxid:9606(human)|taxid:9606(Homo sapiens)" to 9606
{
gsub("taxid:|\\(.*$","",x)
all.IntAct[, Taxid_interactor_A := gsub("taxid:|\\(.*$","",Taxid_interactor_A)]
all.IntAct[, Taxid_interactor_B := gsub("taxid:|\\(.*$","",Taxid_interactor_B)]
all.IntAct[, Host_organisms := gsub("taxid:|\\(.*$","",Host_organisms)]
# saving identifier types and cleaning interactor ids
all.IntAct[, interactor_IDs_databases_A := gsub(":.*$","",IDs_interactor_A)]
all.IntAct[, interactor_IDs_databases_B := gsub(":.*$","",IDs_interactor_B)]
all.IntAct[, IDs_interactor_A := gsub("^.*:","",IDs_interactor_A)]
all.IntAct[, IDs_interactor_B := gsub("^.*:","",IDs_interactor_B)]
all.IntAct[, bait_prey_status_A := gsub("^.*\\(|\\)","",Experimental_roles_interactor_A)]
all.IntAct[, bait_prey_status_B := gsub("^.*\\(|\\)","",Experimental_roles_interactor_B)]
all.IntAct[, Publication_Identifiers := gsub("^.*pubmed:|\\|.*$","",Publication_Identifiers)]
all.IntAct[, Confidence_values := gsub("^intact-miscore:","",Confidence_values)]
all.IntAct[, Confidence_values := gsub("-","NA",Confidence_values)]
all.IntAct[, Confidence_values := as.numeric(Confidence_values)]
}

# checking mixed mouse / human interactions
{
the_host_for_mouse_human_pairs = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb"
           , table(Host_organisms)]
the_host_for_mouse_human_pairs_mouse_as_bait = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey"))
           , table(Host_organisms)]
mouse_as_bait = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey")) &
              Host_organisms == "9606"
           ,.(IDs_interactor_A, IDs_interactor_B, Taxid_interactor_A, Taxid_interactor_B)]
mouse_as_bait_human_preys = length(unique(c(mouse_as_bait[(Taxid_interactor_A == "9606"), IDs_interactor_A], 
                mouse_as_bait[(Taxid_interactor_B == "9606"), IDs_interactor_B])))
mouse_as_bait_mouse_baits = length(unique(c(mouse_as_bait[(Taxid_interactor_A == "10090"), IDs_interactor_A], 
                mouse_as_bait[(Taxid_interactor_B == "10090"), IDs_interactor_B])))
N_pmid_mouse_as_bait_in_human = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey")) &
              Host_organisms == "9606"
           ,length(unique(Publication_Identifiers))]
all.IntAct[Taxid_interactor_A == "9606" & Taxid_interactor_B == "9606", table(Host_organisms)]
}

```

Surprisingly, `r the_host_for_mouse_human_pairs[["9606"]]` interactions between mouse and human proteins were discovered in human rather than mouse cells (only `r the_host_for_mouse_human_pairs[["10090"]]`) suggesting that researchers use mouse proteins as baits (`r mouse_as_bait_mouse_baits` mouse baits total, `r mouse_as_bait_human_preys` human preys total, including isoforms, from `r N_pmid_mouse_as_bait_in_human` publications) to find interactions directly relevant to human interactome research, including human disease.


### BioGRID database (as obtained from Mentha) overlaps significantly with IMEx databases

```{r biogrid_vs_IMEx_vs_Uniprot_processing}
## Enter SPECIES_NAME 
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
## !! no "E.coli strain K12" in BioGRID from Mentha
## ## Use all Uniprot if reviewed == 1, only Swissprot data if reviewed == 2, 
## ## TrEMBL data if reviewed == 3
reviewed = c(1, 2)
## ## Distinguish between isoforms or use only generic Uniprot IDs: TRUE / FALSE?
isoforms = c(FALSE) # not possible to distinguish isoforms for BioGRID

#============================================================================#
source("biogrid_from_mentha_vs_proteome_vs_imex.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
        biogrid_from_mentha_vs_proteome_vs_imex(SPECIES_NAME = n, reviewed = r, isoforms = i, date = date)
    }
  }
}

whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = data.frame()
reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = data.frame()
whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha = data.frame()
source("SPECIES_NAME_TO_ID.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",reviewed = r,"_isoforms_",isoforms = i,"_", date,".txt", sep = "")
      biogrid_from_mentha_vs_proteome_vs_imex_f = as.data.frame(read.delim(filename_vs_3, stringsAsFactors = F))

#============================================================================#
## Calculating overlaps

source("A_vs_B_vs_C_overlap.R")
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                    A = "whole_proteome_Uniprot", 
                    B = "IMEx", 
                    C = "BioGRID_from_Mentha", 
                    SPECIES_NAME = n, reviewed = r, isoforms = i)
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = rbind(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp)

whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                                                                                 A = "whole_proteome_Uniprot", 
                                                                                 B = "X0469.IntAct.", 
                                                                                 C = "BioGRID_from_Mentha", 
                                                                                 SPECIES_NAME = n, reviewed = r, isoforms = i)
whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha = rbind(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha_temp)

reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                                                                                 A = "reference_proteome_Uniprot", 
                                                                                 B = "IMEx", 
                                                                                 C = "BioGRID_from_Mentha", 
                                                                                 SPECIES_NAME = n, reviewed = r, isoforms = i)
reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = rbind(reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp)
    }
  }
}
```

```{r biogrid_vs_IMEx_vs_Uniprot_venndiagram, cache=F, fig.width=8, fig.height=8, fig.cap="Figure 4" }
## Plotting overlaps - Uniprot IMEx BioGRID
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
if(IMExdatabase == "IMEx"){
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha$species_name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha$species_name)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reviewed == 1)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reviewed == 2)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
}
if(IMExdatabase == "X0469.IntAct."){
  whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha$species_name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha$species_name)
  library(dplyr)
  proteome_vs_interactome_summary.all_isof = filter(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, reviewed == 1)
  proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == FALSE)
  proteome_vs_interactome_summary.all_noisof = filter(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, reviewed == 2)
  proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
}
library(VennDiagram)
{
grid.newpage()

plotname = paste0("Proteome coverage by interaction databases, overlap between ", IMExdatabase," and BioGRID")

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("UniprotKB, isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("SwissProt, isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("triple.venn.prot.R")
  venn = triple.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = TRUE)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("triple.venn.prot.R")
  venn = triple.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = TRUE)
  popViewport()
}
popViewport()
}
```

## Which proteins are missing?

```{r human_not_in_IMEx_protein_properties_processing}
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
SPECIES_NAME = "Homo sapiens"
## only reviewed = 2 is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
library(dplyr)
#for (r in reviewed) {
#  for (i in isoforms) {
#    for (n in SPECIES_NAME) {
r = reviewed
i = isoforms
n = SPECIES_NAME
     ##============================================================================##
      ## querying Uniprot for the list of proteins (only mapped to Uniprot)
      ## downolading length, mass, SNPs, isoforms, annotation score, existence attribute
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      ## reading logic table and getting list of proteins
      if(SPECIES_NAME != "strain K12"){
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")}
      if(SPECIES_NAME == "strain K12"){
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")}
      biogrid_from_mentha_vs_proteome_vs_imex_f = as.data.frame(read.delim(filename_vs_3, stringsAsFactors = F))
      IDs = dplyr::filter(biogrid_from_mentha_vs_proteome_vs_imex_f, whole_proteome_Uniprot==1)%>% dplyr::select(whole_proteome_IDs)
      filename_perl = paste0("./Data/IDs_for_PERL_",date,".txt")
      filename_out_of_perl = paste0("./Data/Swissprot_list_from_proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,"")
      file.create(filename_out_of_perl)
      write(IDs$whole_proteome_IDs, file = filename_perl)
      source("download_whole_proteome.R")
      whole_proteome_query = download_whole_proteome(SPECIES_ID, date = "2016-12-14")
      uniprot_query = dplyr::filter(whole_proteome_query, Status == "reviewed")
      ##============================================================================##
      ## merging information from Uniprot to the logic table
      proteome_vs_imex_details_f = merge(filter(biogrid_from_mentha_vs_proteome_vs_imex_f, whole_proteome_Uniprot==1), 
                                         uniprot_query, 
                                         by.x = "whole_proteome_IDs",
                                         by.y = "Entry")
      proteome_vs_imex_details_f$Mass = gsub(",","",proteome_vs_imex_details_f$Mass)
      proteome_vs_imex_details_f$Mass = as.numeric(proteome_vs_imex_details_f$Mass)
      ## creating a factor variable for presence_in_Uniprot.presence_in_IMEx (1_0/1_1)
      proteome_vs_imex_details_f[,length(proteome_vs_imex_details_f)+1] = interaction(proteome_vs_imex_details_f$whole_proteome_Uniprot, proteome_vs_imex_details_f$IMEx, sep = "_")
      colnames(proteome_vs_imex_details_f)[length(proteome_vs_imex_details_f)] = paste0(colnames(proteome_vs_imex_details_f)[2], "_","IMEx")
      levels(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx) = c("SwissProt_not_IMEX", "SwissProt_and_IMEX")
      ##============================================================================##
      ## saving combined logic table + protein properties from Uniprot
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      write.table(proteome_vs_imex_details_f,filename_vs_2,col.names=T,row.names=F,sep="\t",quote=F)
```

### Olfactory receptors are a major group of proteins not represented in IntAct

```{r human_not_in_IMEx_protein_properties_GOenrichment}

```

### Human proteins with no available interactions (from IMEx) are on average shorter than the proteins with interactions available  

```{r human_not_in_IMEx_proteins_are_shorter_density, fig.width=8, fig.height=5, fig.cap="Figure 5" }
      ##============================================================================##
      ## Analysis
      # read the saved table
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
      proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)
                  ## plotting the distribution of mass
      library(ggplot2)
      # ggplot(proteome_vs_imex_details_f, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.5)) +geom_density()+ scale_x_log10()
      # ggplot(proteome_vs_imex_details_f, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.5)) + scale_x_log10() + geom_histogram(position = "identity", bins = 50)
      
      ## removing olfactory receptors:
      {proteome_vs_imex_details_f_minus_odor = proteome_vs_imex_details_f[-grep("Odor", 
                                                                                proteome_vs_imex_details_f$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf = proteome_vs_imex_details_f_minus_odor[-grep("Olfactory",
                                                                                              proteome_vs_imex_details_f$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf.c = rbind(cbind(proteome_vs_imex_details_f, olfac = 
                                                              rep("all SwissProt", nrow(proteome_vs_imex_details_f))),
                                                        cbind(proteome_vs_imex_details_f_minus_odor_olf, olfac = rep("SwissProt excluding \n olfactory receptors",nrow(proteome_vs_imex_details_f_minus_odor_olf))))}
          ## density with and without olfactory receptors:
      ggplot(proteome_vs_imex_details_f_minus_odor_olf.c, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.7, label = olfac)) +geom_freqpoly(bins = 100)+ scale_x_log10() + facet_grid(olfac~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("protein mass, Da, log10 scale") + ggtitle("the distribution of protein mass for proteins with and without interaction evidence")
```

The difference in protein mass between proteins present and absent in the interactome is highly unlikely to be attributed to chance. Wilcox rank test on the whole population of proteins and Monte-Carlo sampling support this statement.

```{r human_not_in_IMEx_proteins_are_shorter_Wilcox}
           ## testing the difference in protein mass distributions
            ##of proteins absent/present in IMEx using Wilcox rank test
      SwissProt_not_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
      wilcox.test.r = wilcox.test(SwissProt_not_IMEX, SwissProt_and_IMEX, conf.int = T)
      wilcox.test.r
                 ## testing the difference in protein mass distributions
            ##of proteins absent/present in IMEx using Wilcox rank test excluding olfactory receptors
      SwissProt_not_IMEX = proteome_vs_imex_details_f_minus_odor_olf$Mass[proteome_vs_imex_details_f_minus_odor_olf$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f_minus_odor_olf$Mass[proteome_vs_imex_details_f_minus_odor_olf$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
      wilcox.test.r = wilcox.test(SwissProt_not_IMEX, SwissProt_and_IMEX, conf.int = T)
      wilcox.test.r
      
                 ## is the distibution of mass or log(mass) normal?
      library(rafalib)
      mypar(2,2)
          
      
      popsd(log10(SwissProt_not_IMEX))
      median(log10(SwissProt_not_IMEX))
      mad(log10(SwissProt_not_IMEX))
      {
      qqnorm(log10(SwissProt_not_IMEX), main = "SwissProt_not_IMEX, log(protein mass)")
      qqline(log10(SwissProt_not_IMEX))
      qqnorm(log10(SwissProt_and_IMEX), main = "SwissProt_and_IMEX, log(protein mass)")
      qqline(log10(SwissProt_and_IMEX))
      qqnorm((SwissProt_not_IMEX), main = "SwissProt_not_IMEX, protein mass")
      qqline((SwissProt_not_IMEX))
      qqnorm((SwissProt_and_IMEX), main = "SwissProt_and_IMEX, protein mass")
      qqline((SwissProt_and_IMEX))
      }

            ## it indeed is
      
                  ## Monte-Carlo simulation
            ## is there a significant difference in protein mass?
      # code can be used for things other than mass
      set.seed(1)
      # sample size
      Ns <- seq(5, 350, 20)
      lengthNs = length(Ns)
      # number of simulations
      B = 1000
      # function which takes samples and does Wilcox test
      simulation = function(n){  
       # x = cbind( matrix(sample(SwissProt_not_IMEX, B*n),B,n)
       # y = matrix(sample(SwissProt_and_IMEX, B*n),B,n)
       # genefilter::rowttests()
        wilcox.test.rr = matrix(0, 1, 3)
        x = sample(SwissProt_not_IMEX, n)
        y = sample(SwissProt_and_IMEX, n)
        wilcox.test.rr[1,c(1,2)] = wilcox.test(x, y, conf.int = T)$conf.int
        wilcox.test.rr[1,3] = wilcox.test(x, y, conf.int = T)$p.value
        return(wilcox.test.rr)
      }
      wilcox.test.rr = matrix(0, lengthNs, 3)
      # looping Monte-Carlo over samples sizes ]
     # for (n in 1:lengthNs) {
     #   z =replicate(B, simulation(Ns[n]), simplify = T)
     #   wilcox.test.rr[n,] = rowMeans(z)
     # }
      xx =cbind(wilcox.test.rr, Ns)
      qplot(xx[,4], xx[,3], ylab = "Wilcox test p-val", xlab = "proteins sampled, N")

```

## What is the relationship between the number of interactions or MI score and the number of publicationions or GO terms per protein?

```{r N_publications_vs_MIscore, fig.height=10, fig.width=10}
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
## Converting UniprotAC to geneID
## Converting UniprotAC isoforms to generic
{
all.IntAct[,IDs_interactor_A_isoforms := IDs_interactor_A]
all.IntAct[,IDs_interactor_B_isoforms := IDs_interactor_B]
source("isoform_id_all_remover.R")
all.IntAct[interactor_IDs_databases_A == "uniprotkb", IDs_interactor_A := isoform_id_all_remover(IDs_interactor_A)]
all.IntAct[interactor_IDs_databases_B == "uniprotkb", IDs_interactor_B := isoform_id_all_remover(IDs_interactor_B)]
}
## copy all.IntAct (data.table doesn't make an explicit copy while assigning DT = data.table())
all.IntAct.modif = copy(all.IntAct)
## downloading the content of the folder containing species specific ID mapping
{# generating filenames
library(RCurl)
uniprotAC2geneID_url = "ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/"
filenames <- getURL(uniprotAC2geneID_url,dirlistonly = TRUE) 
filenames = unlist(strsplit(filenames,"\n"))
filenames = filenames[grep("idmapping.dat.gz",filenames)]
uniprotAC2geneID_filename = paste0("./Data/uniprotAC2geneID","release_", format(Sys.Date(), "%m-%Y"),"_", filenames)
uniprotAC2geneID_filename.dat = substr(uniprotAC2geneID_filename, 1, nchar(uniprotAC2geneID_filename)-3)
}
# downloading and unzipping files
for(i in 1:length(uniprotAC2geneID_filename.dat)){
  if(!file.exists(uniprotAC2geneID_filename.dat[i])) {
    downloader::download(paste0(uniprotAC2geneID_url,filenames[i]), uniprotAC2geneID_filename[i])
  R.utils::gunzip(uniprotAC2geneID_filename[i])
  # make git ignore big files 
  gitignore = c(substr(uniprotAC2geneID_filename.dat[i], 2, nchar(uniprotAC2geneID_filename.dat[i])),
                readLines(".gitignore"))
  write(gitignore, ".gitignore")
}
}
# reading files for uniprotAC to geneID mapping
uniprotAC2geneID = data.table()
for(i in 1:length(uniprotAC2geneID_filename.dat)){
  temp = fread(uniprotAC2geneID_filename.dat[i], header = F)
  temp = temp[V2 == "GeneID", .(V1, V3)]
  uniprotAC2geneID = rbind(uniprotAC2geneID,temp)
  rm(list = "temp")
}

## map GeneIDs for IDs_interactor_A
{
colnames(uniprotAC2geneID)[2] = "IDs_interactor_A_GeneID"
all.IntAct.modif = merge(x=all.IntAct.modif, y=uniprotAC2geneID, by.x = "IDs_interactor_A", by.y = "V1", all.x=TRUE, all.y = F)
#colnames(all.IntAct.modif)
# sum(is.na(all.IntAct.modif$IDs_interactor_A_GeneID))
}
## map GeneIDs for IDs_interactor_B
{#setkey(all.IntAct,IDs_interactor_A)
#x = identical(all.IntAct[,paste0(IDs_interactor_A,IDs_interactor_B)] , all.IntAct.modif[,paste0(IDs_interactor_A,IDs_interactor_B)])
#all.IntAct[IDs_interactor_A %in% c("Q03228","Q3J6C1","Q43393","Q52880","Q55168","Q55168", "A0A0H3K900"),paste0(IDs_interactor_A,"_",IDs_interactor_B)]
#all.IntAct[IDs_interactor_A %in% c("Q03228","Q3J6C1","Q43393","Q52880","Q55168","Q55168", "A0A0H3K900"),paste0(IDs_interactor_A,"_",IDs_interactor_B)]
#all.IntAct[IDs_interactor_A %in% c("Q03228","Q3J6C1","Q43393","Q52880","Q55168","Q55168", "A0A0H3K900")]
colnames(uniprotAC2geneID)[2] = "IDs_interactor_B_GeneID"
all.IntAct.modif = merge(x=all.IntAct.modif, y=uniprotAC2geneID, by.x = "IDs_interactor_B", by.y = "V1", all.x=TRUE, all.y = F)
# colnames(all.IntAct.modif)
# sum(!is.na(all.IntAct.modif$IDs_interactor_B_GeneID))
rm(list = "uniprotAC2geneID")
}


## getting the publication ID for each gene
geneID2pubmed_url = "ftp://ftp.ncbi.nih.gov/gene/DATA/gene2pubmed.gz"
geneID2pubmed_filename = paste0("./Data/geneID2pubmed_release_", format(Sys.Date(), "%m-%Y.gz"))
geneID2pubmed_filename_txt = substr(geneID2pubmed_filename, 1, nchar(geneID2pubmed_filename)-3)
if(!file.exists(geneID2pubmed_filename_txt)) {
  downloader::download(geneID2pubmed_url, geneID2pubmed_filename)
  R.utils::gunzip(geneID2pubmed_filename)
  gitignore = c(substr(geneID2pubmed_filename, 2, nchar(geneID2pubmed_filename)-3), readLines(".gitignore"))
  write(gitignore, ".gitignore")
}

geneID2pubmed = fread(geneID2pubmed_filename_txt, colClasses = c("character","character","character"))
geneID2pubmed = geneID2pubmed[,.(GeneID, PubMed_ID)]

## count the number of pubmed PMID per GeneIDs for IDs_interactor_A and B
{
geneID2pubmed[, interactor_A_total_PMID := length(PubMed_ID), by = GeneID]
geneID2pubmed = geneID2pubmed[,unique(data.table(GeneID,interactor_A_total_PMID))][,GeneID := as.character(GeneID)]
all.IntAct.modif = merge(all.IntAct.modif, geneID2pubmed, by.x = "IDs_interactor_A_GeneID", by.y = "GeneID", all.x=TRUE)
colnames(geneID2pubmed)[2] = "interactor_B_total_PMID"
all.IntAct.modif = merge(all.IntAct.modif, geneID2pubmed, by.x = "IDs_interactor_B_GeneID", by.y = "GeneID", all.x=TRUE)
 colnames(all.IntAct.modif)
 rm(list = "geneID2pubmed")
}


#Count the number of interactions formed by proteins encoded by GeneID
{
all.IntAct.modif[,unique_interactions := apply(data.table(IDs_interactor_A,IDs_interactor_B,stringsAsFactors = F), 1,
                                               function(a) { z = sort(a)
                                               paste0(z[1],"_",z[2]) })]
all.IntAct.modif[,unique_interactions_isoforms := apply(data.table(IDs_interactor_A,IDs_interactor_B,stringsAsFactors = F), 1,
                                               function(a) { z = sort(a)
                                               paste0(z[1],"_",z[2]) })]
  #UniprotID
all.IntAct.modif[,unique_interactions_per_interactor_A := length(unique(grep(IDs_interactor_A, unique_interactions ,value = T))), by = IDs_interactor_A]
all.IntAct.modif[,unique_interactions_per_interactor_B := length(unique(grep(IDs_interactor_B, unique_interactions ,value = T))), by = IDs_interactor_B]
  #GeneID
all.IntAct.modif[,unique_interactions_per_interactor_A_GeneID := length(unique(grep(IDs_interactor_A, unique_interactions ,value = T))), by = IDs_interactor_A_GeneID]
all.IntAct.modif[,unique_interactions_per_interactor_B_GeneID := length(unique(grep(IDs_interactor_B, unique_interactions ,value = T))), by = IDs_interactor_B_GeneID]
  #UniprotID isoform
all.IntAct.modif[,unique_interactions_per_interactor_A_isoforms := length(unique(grep(IDs_interactor_A_isoforms, unique_interactions_isoforms ,value = T))), by = IDs_interactor_A_isoforms]
all.IntAct.modif[,unique_interactions_per_interactor_B_isoforms := length(unique(grep(IDs_interactor_B_isoforms, unique_interactions_isoforms ,value = T))), by = IDs_interactor_B_isoforms]
}

# interactions to proteins and genes
{
  all.IntAct.proteins = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   interactor_total_PMID = c(interactor_A_total_PMID,interactor_B_total_PMID),
                   Confidence_values = as.numeric(c(Confidence_values,Confidence_values)),
                   Taxid_interactor = c(Taxid_interactor_A,Taxid_interactor_B),
                   interactor_IDs_databases = c(interactor_IDs_databases_A, interactor_IDs_databases_B),
                   interactor_GeneID = c(IDs_interactor_A_GeneID, IDs_interactor_B_GeneID),
                   unique_interactions_per_interactor = c(unique_interactions_per_interactor_A, unique_interactions_per_interactor_B),
                   unique_interactions_per_gene = c(unique_interactions_per_interactor_A_GeneID, unique_interactions_per_interactor_B_GeneID),
                   unique_interactions_per_interactor_isoforms = c(unique_interactions_per_interactor_A_isoforms, unique_interactions_per_interactor_B_isoforms))]
  all.IntAct.proteins = unique(all.IntAct.proteins)
  all.IntAct.proteins[,Median_MI_score := median(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins[,Mean_MI_score := mean(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins[,Confidence_values := NULL]
  all.IntAct.proteins = unique(all.IntAct.proteins)
  all.IntAct.proteins = all.IntAct.proteins[Taxid_interactor %in% c("9606", "10090", "559292","83333","7227", "6239","3702") & interactor_IDs_databases == "uniprotkb",]
  # filter out proteins mapped to more than one geneID and not mapped to geneID
  all.IntAct.proteins = all.IntAct.proteins[,n_geneid := as.numeric(length(interactor_GeneID)),by = IDs_interactor][n_geneid ==1,]
  all.IntAct.proteins = all.IntAct.proteins[,n_protid := as.numeric(length(IDs_interactor)),by = interactor_GeneID][n_protid <10,]
  # nrow(unique(all.IntAct.proteins[Taxid_interactor %in% c("9606"), ]))
  # length(unique(all.IntAct.proteins[Taxid_interactor %in% c("9606"), IDs_interactor]))
  SPECIES_NAME_ID = data.table(SPECIES_ID = c("9606", "10090", "559292","83333","7227", "6239","3702"), SPECIES_NAME)
  all.IntAct.proteins = merge(all.IntAct.proteins, SPECIES_NAME_ID, by.x = "Taxid_interactor", by.y = "SPECIES_ID", all=TRUE)
  all.IntAct.proteins = all.IntAct.proteins[complete.cases(all.IntAct.proteins),]
  str(all.IntAct.proteins)
}

plot(all.IntAct.proteins$Median_MI_score,all.IntAct.proteins$Mean_MI_score, main = "Median_MI_score vs Mean_MI_score")

# how many geneID per protein?
all.IntAct.proteins[,table(n_geneid,useNA = "ifany")]
all.IntAct.proteins[,table(n_protid,useNA = "ifany")]
mean(all.IntAct.modif[,is.na(Confidence_values)])
mean(all.IntAct.proteins[,is.na(Median_MI_score)])

library(MASS)
# plotting Median_MI_score as a function of the number of publications 
{
ggplot(all.IntAct.proteins, aes(interactor_total_PMID, Median_MI_score))+
    geom_density_2d(bins = 30,aes(colour=..level..)) + scale_x_log10() + 
     scale_color_gradient(low = "grey", high = "black", breaks=c(0,10,50,100,200,500))+
    ggtitle("The relationship between the number of publications per gene and median MI score", subtitle = "line was fitted using robust linear regression")+
    ylab("median MI score for the interactions \n including the proteins encoded by that gene") + xlab("the number of publications per gene") +
     geom_smooth(method = "rlm", se = T) +ylim(0,1)+
  facet_wrap(~SPECIES_NAME, scales = "free") + geom_point(size = 0.1, alpha = 0.05)
}
# plotting Mean_MI_score as a function of the number of publications 
{
ggplot(all.IntAct.proteins, aes(interactor_total_PMID, Mean_MI_score))+facet_wrap(~SPECIES_NAME, scales = "free") +
    geom_density_2d(bins = 30,aes(colour=..level..)) + scale_x_log10() + 
     scale_color_gradient(low = "grey", high = "black", breaks=c(0,10,50,100,200,500))+
    ggtitle("The relationship between the number of publications per gene and mean MI score", subtitle = "line was fitted using robust linear regression")+
    ylab("mean MI score for the interactions \n including the proteins encoded by that gene") + xlab("the number of publications per gene") +
     geom_smooth(method = "rlm", se = T) +geom_point(size = 0.1, alpha = 0.05)+ylim(0,1)
}
fit = rlm(Median_MI_score~interactor_total_PMID, data=all.IntAct.proteins)
summary(fit)

```

```{r N_publications_vs_N_interactions, fig.height=10, fig.width=10}

# plotting unique_interactions_per_interactor as a function of the number of publications 
{
ggplot(all.IntAct.proteins, aes(interactor_total_PMID, unique_interactions_per_interactor))+
    geom_density_2d(bins = 30,aes(colour=..level..)) + scale_x_log10()+ scale_y_log10()  + 
     scale_color_gradient(low = "grey", high = "black", breaks=c(0,10,50,100,200,500))+
    ggtitle("The relationship between the number of publications per gene and \n the number of interactions in which proteins encoded by that gene participate", subtitle = "line was fitted using robust linear regression, \n all UniprotAC were coerced to generic UniprotAC")+
    ylab("the number of interactions(per protein) in which proteins encoded by that gene participate") + xlab("the number of publications per gene") +
     geom_smooth(method = "rlm", se = T)+
  facet_wrap(~SPECIES_NAME, scales = "free") + geom_point(size = 0.1, alpha = 0.05)
}

# plotting unique_interactions_per_gene as a function of the number of publications 
{
ggplot(all.IntAct.proteins, aes(interactor_total_PMID, unique_interactions_per_gene))+
    geom_density_2d(bins = 30,aes(colour=..level..)) + scale_x_log10()+ scale_y_log10()  + 
     scale_color_gradient(low = "grey", high = "black", breaks=c(0,10,50,100,200,500))+
    ggtitle("The relationship between the number of publications per gene and \n the number of interactions in which proteins encoded by that gene participate", subtitle = "line was fitted using robust linear regression, \n all UniprotAC were coerced to generic UniprotAC")+
    ylab("the number of interactions (per gene) in which proteins encoded by that gene participate") + xlab("the number of publications per gene") +
     geom_smooth(method = "rlm", se = T)+
  facet_wrap(~SPECIES_NAME, scales = "free") + geom_point(size = 0.1, alpha = 0.05)
}

# plotting unique_interactions_per_interactor_isoform as a function of the number of publications 
{
ggplot(all.IntAct.proteins, aes(interactor_total_PMID, unique_interactions_per_interactor_isoforms))+
    geom_density_2d(bins = 30,aes(colour=..level..)) + scale_x_log10()+ scale_y_log10()  + 
     scale_color_gradient(low = "grey", high = "black", breaks=c(0,10,50,100,200,500))+
    ggtitle("The relationship between the number of publications per gene and \n the number of interactions in which proteins encoded by that gene participate", subtitle = "line was fitted using robust linear regression, \n including isoform-specific interactions")+
    ylab("the number of interactions (per isoform) in which proteins encoded by that gene participate") + xlab("the number of publications per gene") +
     geom_smooth(method = "rlm", se = T)+
  facet_wrap(~SPECIES_NAME, scales = "free") + geom_point(size = 0.1, alpha = 0.05)
}
```

# Supplementary figures

Supplementary figure 1 

```{r Supplementary1_IMEx_vs_Uniprot_venndiagram_all_Uniprot, cache=F, fig.width=8, fig.height=8, fig.cap="Supplementary figure 1"}
## Plotting with venn.diagram - Uniprot vs IMEx (or IntAct)
# code to be modified for different graphs
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
reviewed_venn = 1                 # 1 or 2
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
proteome_vs_interactome_summary.all$species.name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", proteome_vs_interactome_summary.all$species.name)
proteome_vs_interactome_summary.all$species.name = gsub("strain K12", "Escherichia coli, strain K12", proteome_vs_interactome_summary.all$species.name)
SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", SPECIES_NAME)
SPECIES_NAME = gsub("strain K12", "Escherichia coli, strain K12", SPECIES_NAME)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == TRUE)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, database == IMExdatabase)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, database == IMExdatabase)

library(VennDiagram)
{
grid.newpage()

if(reviewed_venn == 2){plotname = paste0("Proteome (SwissProt) coverage by interaction databases(",IMExdatabase,")")
databasename = "SwissProt"}
if(reviewed_venn == 1){plotname = paste0("Proteome (all UniprotKB) coverage by interaction databases(",IMExdatabase,")")
databasename = "UniprotKB"}

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("isoforms included", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
}
popViewport()
}
```

Supplementary figure 2

```{r BioGRID_vs_IMEx_vs_Uniprot_N_Uniprot&Species, cache=F, fig.width=8, fig.height=8, fig.cap="Supplementary figure 2" }
### combine the summaries for multiple species of how many interactors have non-uniprot identifiers
interactome_identifiers_summary.all = data.frame()
for (i in isoforms) {
  for(n in SPECIES_NAME) {
    filename.summary = paste("./summaries/","uniprotKB_IDs_and_",n,"_biogrid_from_mentha_interactors_summary", "_isoforms_",i,"_", date,".txt", sep = "")
    if(!file.exists(filename.summary)) {
      interactome_identifiers_summary.all
    }
    if(file.exists(filename.summary)) {
      interactome_identifiers_summary.o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
      interactome_identifiers_summary.all = rbind(interactome_identifiers_summary.all, interactome_identifiers_summary.o)
    }
  }
}
interactome_identifiers_summary.all = unique(interactome_identifiers_summary.all)
## save all species summary
filename.summary.all = paste("./results/","interactome_identifiers_BioGRID_summary_",date,".txt", sep = "")
write.table(interactome_identifiers_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)

#################
interactome_identifiers_summary.all.s = interactome_identifiers_summary.all[,c(3,4,5,6,7)]
## Transform table for plotting with ggplot2
library(reshape2)
interactome_identifiers_summary.all.s.m= melt(data = interactome_identifiers_summary.all.s,
                                              id.vars = c("SPECIES_NAME", "SPECIES_ID"),
                                              variable.name = "decription",
                                              value.name = "number")
interactome_identifiers_summary.all.s.m=unique(interactome_identifiers_summary.all.s.m)
## rename yeast and E.coli
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain K12", "E. coli, strain K12", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Caenorhabditis elegans", "C. elegans", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Drosophila melanogaster", "D. melanogaster", interactome_identifiers_summary.all.s.m$SPECIES_NAME)

# plot
library(ggplot2)
library(dplyr)

proteome_vs_interactome_plot <- ggplot(interactome_identifiers_summary.all.s.m, aes(x=SPECIES_NAME, y=number, fill=decription,label=number)) + geom_bar(width = 0.9, stat = "identity", position = "stack") + geom_label(position = "stack", size = 4, label.padding = unit(0.08, "lines")) +
  ggtitle("The number of interactors which have UniprotKB identifiers \n and belong to the species queried") + theme(axis.text.x=element_text(angle = 20), axis.title.x = element_text(size = 0)) + ylab("number of proteins")
proteome_vs_interactome_plot
# save plot
# filename=paste("./results/", "interactome_identifiers_summary_plot_SMALL",date,".png", sep = "")
# ggsave(filename, proteome_vs_interactome_plot, width = 12, height = 12)

### ======================================================================== ###

```
