
--- 
title: Characterisation of model species interactome available from primary molecular
  interaction databases
author: "Vitalii Kleshchevnikov"
date: "21 December 2016"
output:
  html_document:
    font-family: Helvetica
    keep_md: yes
    toc: yes
  pdf_document:
    font-family: Helvetica
    keep_tex: yes
    latex_engine: lualatex
    toc: yes
  word_document: default
--- 
 
```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = FALSE, results = "hide", warning = FALSE, message = FALSE, fig.keep = "all") 
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(UniProt.ws)
  library(PSICQUIC)
  library(ggplot2)
  library(clusterProfiler)
})
  source("multiplot.R")
  source("GO_analyse_simplify_plot.R")
# library(devtools)
# install_github("vitkl/clusterProfiler")
# install_github("vitkl/DOSE")

date = Sys.Date()
## Please specify the date for which you want to perform analysis (if not today)
date = as.Date("2017-04-24")
# git update-index --assume-unchanged .RData 
# http://stackoverflow.com/questions/21043132/gitignore-just-doesnt-work-i-cant-get-it-to-ignore-ds-store-gitignore-fil
``` 

The report was published on `r Sys.Date()`. All data used in the report as available on `r date`.

# Outline

1. Abstract
2. Introduction
3. Methods
4. Results and discussion
    - how available interactome covers the proteome
    - IMEx(IntAct) vs Biogrid
    - which proteins are missing
    - interaction detection biases
    - study bias: the more articles, the more interactions
    - which proteins are IMEx(IntAct), Biogrid and high-throughput datasets enriched in?
5. Conclusion  

# Abstract


# Introduction 
 
   The structure and the function of the cell arise from interactions between molecules inside and outside it. Though proteins, nucleic acids, lipids and small molecules can all form important interactions, studies and literature focus mainly on interactions between proteins and other macromolecules. We can discover and study these molecular interactions using a number of experimental and computational techniques. This study focuses on molecular interactions identified in the experimental setting, most of which are represented in the literature and databases by protein-protein interactions (also protein-DNA interactions obtained, for example, by ChIP-Seq, but those are traditionally incorporated into genomic databases).  
 
   Based on the information detection methods can provide towards ground truth we can classify interactions in three types: binary interactions and associations. Binary interactions are the interactions between two components, for example, two specific proteins, some detection methods (e.g. two-hybrid) identify those. To understand associations, we need to imagine we know proteins A, B and C constitute a complex and interact as shown in a figure 1 A. When we conduct an experiment, we choose the bait (the molecule experimentally treated to capture its interacting partners - called preys) to be protein A, and by detection method (e.g. affinity-purification mass spectrometry) we get both protein B and protein C detected as preys. Next step is to translate bait-prey relationship into a model of reality like the one shown in the figure 1 A. We call interactions between A-B and A-C associations because we cannot infer the true relationship between A, B, and C from this experiment design. In the other words, establishing that proteins are in direct physical contact is really challenging. However, to represent associations in a tabular format with each row corresponding to one interaction (e.g. A-B) we need to expand those. Two ways are commonly used to expand interactions, hub and spoke expansion, both shown in the figure 1 B. 

#### Defining interactome

   The aggregation of all components and their interactions into a single network result in what we call interactome, the whole of all molecular interactions. You can also look into the subset of this network, for example, you can select only proteins, only those proteins that are expressed in the brain, and only the interactions between this protein identified experimentally in the brain cells. This example reflects the complexity and the diversity of the interactome - which is what you would expect from a system underlying the complexity and the diversity of the cell types, cellular behaviours, and functions. For the same reason, only by studying these interactions and how they change in specific cell types and under specific circumstances in combination with the functional analysis we can decipher cellular regulatory networks. The ultimate goal of the research in the field would be to capture all physical interactions and thoroughly describe them while avoiding false discoveries. 

#### Experimental approaches for discovering interactions

   Experimental protein interaction detection methods can be classified into 3 main categories based on the evidence they provide and whether they can be used in a high-throughput manner:
The first category is formed by methods using affinity purification of the bait and all the prey associated with it. Following that, preys can be identified using western-blotting and specific antibodies or using mass-spectrometry, which can be done in a high-throughput manner [Mann, ]. The main advantage of these methods is the ability to quantitatively characterise interactions [Mann, ] and capture many prey proteins per bait - the latter, however, presents the disadvantage of dealing with associations. The main disadvantage of these techniques is that for the reliable result it requires all interacting proteins to be soluble []. 
   The second category is formed by protein complementation techniques which include two-hybrid (transcription factor complementation), the most widely used interaction detection method (including high-throughput experiments). In this method, pairs of proteins are tested for interaction and therefore all discovered interactions are binary (the main advantage of this method). Classic implementation of two-hybrid requires proteins to be soluble as well [], however, two-hybrid for membrane proteins was also developed []. The main disadvantage of two-hybrid methods are that they allow only qualitative characterisation of interactions [], are usually performed in yeast (thus, have a lower sensitivity) and are highly prone to false-positive results [].
   Final category consists of methods based on the structure of the protein complex. They can provide valuable information on how exactly physical interaction occurs but as for now are extremely labor-intensive and will always need complementary experiments showing if the proteins actually interact in the cellular context.

#### Challenges of interactomics

   Four big challenges substantially complicate the study of molecular interactions, especially on the whole organism scale. The first being that we don't know the true nature of underlying our experimental results (all assays provide evidence that interaction is possible and some can provide quantitative description, but all are prone to error and the problem described in the figure 1 A) which lead to the necessity of combining interaction data from multiple experiments and complex statistical evaluation of how probable the interaction is based on that data (Bayesian approach [1]) rather than receiving confident yes-or-no result from single experiment. Interaction databases make an effort to score the interactions based on supporting evidence, however, this is usually done with non-probabilistic heuristic approaches, like MI score [PMCID: PMC4316181]. 

   The second big challenge is the problem of "noise" - or false positives. Different interaction detection experiments are prone to these errors for different reasons, for example, in-vitro experiments (e.g. TAP-MS) may allow the interaction between proteins which are normally included in separate cellular compartments. Specific groups of proteins (based on their physical or chemical properties) may have a higher susceptibility to false positives, for example, intermediate filaments (e.g. nuclear lamins) have low solubility under non-denaturing conditions necessary for affinity-purification based techniques, which may lead to artifactual results. However plausible, this particular problem lacks empirical evidence and requires more investigation. A more general problem of noise will be addressed by more proteome-scale interactomics experiments (which can include enough samples to guarantee low false positive rate while still identifying interactions).

   The third big challenge is that our knowledge of interactome is incomplete and arises from the fact that experimental approaches have low statistical power and often miss out some real interactions. Also, many proteins, especially for non-popular model species, were not researched for protein interactions.

   The final challenge contributes to the "incomplete interactome" problem but is grounded in the fact that not all protein interaction discovered and published are included in protein interaction databases. In the other words, this is database curation problem. More than 100 public databases containing protein interactions are available now. These databases differ:
- by the types of data they include (e.g. computational prediction, manual curation from experimental articles - primary, aggregated data from many primary databases - secondary),  
- the level of detail captured from articles to describe interactions,  
- how often and if they are updated with new data.  
   The level of detail ranges from only mentioning the pairs of interactors and heuristic score assigned to them (STRING, updated once in 2 years) to the ones containing experiment details (detection method, bait/prey status, if available - quantitative data, experiment setup, protein variants), such as IntAct [PMCID: PMC3703241]. 
   The amount of interaction data generated per year is growing exponentially making manual curation of all this data into primary databases a daunting task. To prioritise curation efforts and reduce redundancy between databases (to curate different data using the same standards) IMEx consortium was formed in 2012 [PMCID: PMC3703241]. IMEx-compliant databases include all big primary databases excluding only BioGRID (which curates at the lower level of detail) and not active legacy databases.

#### Motivation for this study

   Solving some of these challenges may be easier than the others. In particular, to solve the last challenge we can prioritise curation efforts for already published interactions to cover unrepresented proteins and we can encourage authors to submit their results to the databases prior to publishing. We can also encourage research of underrepresented parts of the interactome. However, for both of those aims, we need to characterise the interactome already present in interaction databases. Specifically, to learn how available interactome covers the proteome of main model species, if there are any biases to proteins with no available interactions and if any major protein interaction detection methods exhibit any biases towards specific groups of proteins. 
   The other helpful to look at the problem is to search for underrepresented in interaction databases but in general well-researched proteins.

# Aims of the study 

1. Find out how available interactome covers the proteome of main model species. Considering either all UniProtKB or SwissProt entries only as the proteome (canonical identifiers as well as protein isoforms). Consider all interactions from IMEx-compliant databases as interactome.  

2. Compare the coverage of proteome by interactome from IMEx to the interactome from BioGRID (the other major primary database).

3. Find out if proteins with no available interactions stand out by specific functions (Gene Ontology, GO: biological process and molecular function), cellular localisation (GO), molecular mass, or protein evidence status from SwissProt

4. Find out if major protein interaction detection methods (two-hybrid and AP-MS, AP-WB?) exhibit any bias towards biochemical properties of the proteins involved (mass, disordered regions, hydropathy, the fraction of charged residues)

5. What is the relationship between the number of interactions or MI score and the number of publications or GO terms per protein?

6. Are proteins with a higher fraction of intrinsically disordered domains more likely to have interactions available and do they have more interactions (if normalised for how well-studied proteins are)?

7. Find out if there are any proteins which are in general well researched (many associated publications or manual GO annotations) but underrepresented in IntAct (low MI score)

8. If that is possible to measure: do intermediate filaments (or other highly insoluble proteins) really have higher rates of false-discovered interactions?

# Methods - data processing and analysis

### Getting proteome from UniProtKB

   Whole proteome (all UniProtKB) for each species was downloaded programmatically in R using UniProt rest API. SwissProt-proteome was subset from the whole proteome by reviewed status column. UniProt identifies proteins by UniProtKB/AC (e.g. P04637, accession) which does not distinguish between protein isoforms. UniProt aggregates isoform information and identifiers (e.g. P04637-4) in a separate column with zero to many isoforms per each UniProtKB accession. To generate proteome list which includes protein isoforms, isoform accessions were extracted and combined with the list of generic accessions. In this analysis, protein evidence status and protein mass are only attributed to generic accessions. 

### Getting and transforming interactome data from IMEx databases and BioGRID

   Interactome from all IMEx databases was downloaded programmatically in R using PSIQUIC package from Bioconductor [Paul Shannon (2015). PSICQUIC]. IMEx databases include IntAct, MINT, bhf-ucl, MPIDB, MatrixDB, HPIDb, I2D-IMEx, InnateDB-IMEx, MolCon, UniProt, MBInfo. The list of interactions (pairs of interactors) was transformed into the list of interactors preserving interactor identifiers, the type of interactor identifier, species information and the database interaction originates from. Only unique proteins wereIMEx databases contain interactions between proteins, RNA, DNA and small molecules, moreover, these interaction may involve molecules originating from different species. Therefore, to perform by species interactome/proteome comparison there is a need to remove non-UniProtKB/AC molecule identifiers (which removes non-protein molecules, although, may also remove a small fraction of proteins which have no UniProtKB/AC) and there is a need to remove proteins originating from other species. Also, entries in IMEx databases has to be cleaned of tags and textual descriptions ("taxid:9606(human-h1299)|taxid:9606(Homo sapiens lung lymph node carcinoma)" to "9606") to make further analysis easier and cleaner.
   Next, when provided in the research articles protein isoform information is always included in IMEx databases, so to perform analysis excluding isoform information UniProtKB/AC were cleaned of -N suffix (P04637-4 to P04637).


### Disordered regions and physical properties

   Information on disordered region content and biochemical properties of individual proteins were obtained from the dataset generated by Vincent and  Schnell in 2015 []. Briefly, Vincent and  Schnell used a number of disorder prediction algorithms (IUPred and DisEMBL) and their consensus to generate disordered region predictions for each protein which was be used to calculate the fraction of disordered regions in a protein. In addition, Vincent and  Schnell used localCIDER version 0.1.7 (Classification of Intrinsically Disordered Ensemble Regions) to calculate physical properties such as a fraction of charged residues, mean hydrophobicity or charge separation for each protein. This was done for 10 eukaryotic proteomes and written to SQLite-database which was made available online.

### Gene ontology enrichment analysis

   coming soon
   
# Results

## 1. How well available interactome covers the proteome

```{r IMEx_vs_Uniprot_processing, cache=F}
# if the analysis has been done - don't do it again
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
filename.summary.all2 = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",date,".txt", sep = "")
filename.summary.all3 = paste("./results/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",date,".txt", sep = "")
if(!file.exists(filename.summary.all)){

SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")

## ## Use all Uniprot if reviewed == 1, only Swissprot data if reviewed == 2, 
## ## TrEMBL data if reviewed == 3
reviewed = c(1, 2)

## ## Distinguish between isoforms or use only generic Uniprot IDs: TRUE / FALSE?
isoforms = c(TRUE, FALSE)

## missing_proteins = TRUE => proteins missing protein evidence are shown
## missing_proteins = FALSE => proteins for which protein evidence exists are shown
missing_proteins = TRUE

## The code below queries databases, saves and processes results, 
## gives summary on how many interactors have Uniprot IDs or belong to the SPECIES_NAME
## generates table with 0 and 1 for the combination of SPECIES_NAME, reviewed, isoforms

  ## type in exact database names (the list below is the default for the function)
  databases <- c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
                 "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")

source("intact_vs_uniprot.R")
for (i in isoforms) {
  for (r in reviewed) {
    for (n in SPECIES_NAME) {
      intact_vs_uniprot(SPECIES_NAME = n, reviewed = r, isoforms = i, missing_proteins = TRUE, date = date, databases = databases)
      message(paste("- ",n," -  reviewed", r, " -  isoforms included", i))
    }
  }
}

## The code below does overlap comparisons and saves summaries
source("intact_vs_uniprot_overlap.R")
source("SPECIES_NAME_TO_ID.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      intact_vs_uniprot_overlap(SPECIES_NAME = n, SPECIES_ID = SPECIES_ID, reviewed = r, isoforms = i, date)
      message(paste("- ",n," -  reviewed", r, " -  isoforms included", i))
    }
  }
}

### combine the summaries for multiple species
proteome_vs_interactome_summary.all = data.frame()
whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all = data.frame()
whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all = data.frame()
for (r in reviewed) {
  for (i in isoforms) {
    for(n in SPECIES_NAME) {
      #=====================================
      filename.summary = paste("./summaries/","proteome_vs_interactome_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary)) {
        proteome_vs_interactome_summary.all
      }
      if(file.exists(filename.summary)) {
        proteome_vs_interactome_summary_o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
        proteome_vs_interactome_summary.all = rbind(proteome_vs_interactome_summary.all, proteome_vs_interactome_summary_o)
      }
      #=====================================
      filename.summary2 = paste("./summaries/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary2)) {
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all
      }
      if(file.exists(filename.summary2)) {
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist = as.data.frame(read.delim(filename.summary2, stringsAsFactors = F))
        whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all = rbind(whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all, whole_proteome_Uniprot_vs_IMEx_vs_protein.exist)
      }
      #=====================================
      filename.summary3 = paste("./summaries/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",n,"_reviewed_",r,"_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary3)) {
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all
      }
      if(file.exists(filename.summary3)) {
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist = as.data.frame(read.delim(filename.summary3, stringsAsFactors = F))
        whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all = rbind(whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all, whole_proteome_Uniprot_vs_IntAct_vs_protein.exist)
      }
  }
}
}
## save all species summary
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
write.table(proteome_vs_interactome_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)
filename.summary.all2 = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_protein.exist_summary_",date,".txt", sep = "")
write.table(whole_proteome_Uniprot_vs_IMEx_vs_protein.exist.all, filename.summary.all2, col.names=T,row.names=F,sep="\t",quote=F)
filename.summary.all3 = paste("./results/","whole_proteome_Uniprot_vs_IntAct_vs_protein.exist_summary_",date,".txt", sep = "")
write.table(whole_proteome_Uniprot_vs_IntAct_vs_protein.exist.all, filename.summary.all3, col.names=T,row.names=F,sep="\t",quote=F)
}

{
  if(file.exists(filename.summary.all)) proteome_vs_interactome_summary.all = fread(filename.summary.all, sep = "\t", stringsAsFactors = F, data.table = F)
}
```

### Available interactome covers substantial fraction of the reviewed proteome of main model species

   In this section, we compare the list of all proteins (per species) in Uniprot (reviewed part (or SwissProt) - Figure 2, reviewed and unreviewed parts (or all UniProtKB: SwissProt + trEMBL) - Supplementary Figure 1) to the list of proteins which have interaction partners annotated in IMEx consortium databases. 
   Non-canonical protein isoform identifiers (P32054-1) were converted to canonical identifiers (P32054) resulting in interactions "any isoform to any isoform" (Venn diagrams on the right) or isoform identifiers were preserved (Venn diagrams on the left). You can see that adding isoform information adds more proteins to the SwissProt list but not so many proteins to the IMEx list.

```{r IMEx_vs_Uniprot_venndiagram, cache=F, fig.width=8, fig.height=8, fig.cap="Figure 2"}
## Plotting with venn.diagram - Uniprot vs IMEx
# code to be modified for different graphs
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
reviewed_venn = 2                 # 1 or 2
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
proteome_vs_interactome_summary.all$species.name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", proteome_vs_interactome_summary.all$species.name)
proteome_vs_interactome_summary.all$species.name = gsub("strain K12", "Escherichia coli, strain K12", proteome_vs_interactome_summary.all$species.name)
SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", SPECIES_NAME)
SPECIES_NAME = gsub("strain K12", "Escherichia coli, strain K12", SPECIES_NAME)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn & isoforms == TRUE & database == IMExdatabase)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn & isoforms == FALSE & database == IMExdatabase)

library(VennDiagram)
{
source("double.venn.prot.R")
grid.newpage()

if(reviewed_venn == 2){plotname = paste0("Proteome (SwissProt) coverage by interaction databases(",IMExdatabase,")")
databasename = "SwissProt"}
if(reviewed_venn == 1){plotname = paste0("Proteome (all UniprotKB) coverage by interaction databases(",IMExdatabase,")")
databasename = "UniprotKB"}

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("isoforms included", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  venn = double.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  venn = double.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
}
popViewport()
}

human_isoform = proteome_vs_interactome_summary.all_isof$whole.proteome..Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] - proteome_vs_interactome_summary.all_noisof$whole.proteome..Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"]

human_isoform_with_interactions = proteome_vs_interactome_summary.all_isof$whole.proteome..interactome.available[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] - proteome_vs_interactome_summary.all_noisof$whole.proteome..interactome.available[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] + (proteome_vs_interactome_summary.all_isof$interactome..but.not.in.Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"] - proteome_vs_interactome_summary.all_noisof$interactome..but.not.in.Uniprot[proteome_vs_interactome_summary.all_isof["species.name"]=="Homo sapiens"])
```

   Overall - the best interactome annotated by IMEx databases is baker’s yeast, 2nd best interactome is *E.coli*. All other interactomes cover less than the half of their respective proteome (all UniProtKB, Supplementary figure 1). The overlap between the interactome and reviewed proteome (SwissProt) is significantly better. 
   A large fraction of human, mouse, arabidopsis proteins-interactors and more than a half of drosophila and *C.elegans* proteins-interactors are absent in SwissProt (but included in trEMBL) – suggesting under-annotation by the SwissProt-Uniprot team.
Protein isoforms (in multicellular model organisms) are almost not annotated in the interactome. Human is an exception – `r human_isoform_with_interactions` protein isoforms out of `r human_isoform`. Other molecular interaction databases (active BioGRID, inactive HPRD) do not record isoform information.

## 2. BioGRID database (as obtained from Mentha) overlaps significantly with IMEx databases

   BioGRID database is the second major primary protein interaction database which when combined with IntAct contains all interactions information which has been curated to currently active public databases (major inactive or legacy databases include HPRD and BIND). BioGRID is characterised by shallow curation level (retains only some information about the interaction and the experiment) and identifies proteins using Entrez Gene ID while IntAct uses UniProtKB identifiers. Entrez Gene ID does not allow to distinguish between different protein isoforms. In our analysis, this difference introduces additional mapping step (Gene ID to UniProtKB). Mentha database has imported all BioGRID-stored interactions and has mapped Gene ID to UniProtKB, so we used Mentha to get BioGRID-stored interactions. Mentha doesn't import interactions for *E.coli*, therefore *E.coli* is absent in this analysis.
   BioGRID has recently incorporated a large-scale study aimed, in part, for find interacting partners for the proteins missing them []. 

```{r biogrid_vs_IMEx_vs_Uniprot_processing}
filename.summary.all_biog = paste("./results/","whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_summary_",date,".txt", sep = "")
if(!file.exists(filename.summary.all_biog)){
  
## Enter SPECIES_NAME 
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
## !! no "E.coli strain K12" in BioGRID from Mentha
## ## Use all Uniprot if reviewed == 1, only Swissprot data if reviewed == 2, 
## ## TrEMBL data if reviewed == 3
reviewed = c(1, 2)
## ## Distinguish between isoforms or use only generic Uniprot IDs: TRUE / FALSE?
isoforms = c(FALSE) # not possible to distinguish isoforms for BioGRID

#============================================================================#
source("biogrid_from_mentha_vs_proteome_vs_imex.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
        biogrid_from_mentha_vs_proteome_vs_imex(SPECIES_NAME = n, reviewed = r, isoforms = i, date = date)
    }
  }
}

whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = data.frame()
reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = data.frame()
whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha = data.frame()
source("SPECIES_NAME_TO_ID.R")
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",reviewed = r,"_isoforms_",isoforms = i,"_", date,".txt", sep = "")
      biogrid_from_mentha_vs_proteome_vs_imex_f = as.data.frame(read.delim(filename_vs_3, stringsAsFactors = F))

#============================================================================#
## Calculating overlaps

source("A_vs_B_vs_C_overlap.R")
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                    A = "whole_proteome_Uniprot", 
                    B = "IMEx", 
                    C = "BioGRID_from_Mentha", 
                    SPECIES_NAME = n, reviewed = r, isoforms = i)
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = rbind(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp)

whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                                                                                 A = "whole_proteome_Uniprot", 
                                                                                 B = "X0469.IntAct.", 
                                                                                 C = "BioGRID_from_Mentha", 
                                                                                 SPECIES_NAME = n, reviewed = r, isoforms = i)
whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha = rbind(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha_temp)

reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp = A_vs_B_vs_C_overlap(biogrid_from_mentha_vs_proteome_vs_imex_f, 
                                                                                 A = "reference_proteome_Uniprot", 
                                                                                 B = "IMEx", 
                                                                                 C = "BioGRID_from_Mentha", 
                                                                                 SPECIES_NAME = n, reviewed = r, isoforms = i)
reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = rbind(reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reference_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha_temp)
    }
  }
}
write.table(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, filename.summary.all_biog, col.names=T,row.names=F,sep="\t",quote=F)
}

{
  if(file.exists(filename.summary.all_biog)) whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha = fread(filename.summary.all_biog, sep = "\t", stringsAsFactors = F, data.table = F)
}
```

```{r biogrid_vs_IMEx_vs_Uniprot_venndiagram, cache=F, fig.width=8, fig.height=8, fig.cap="Figure 4" }
## Plotting overlaps - Uniprot IMEx BioGRID
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
if(IMExdatabase == "IMEx"){
whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha$species_name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha$species_name)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reviewed == 1)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(whole_proteome_Uniprot_vs_IMEx_vs_BioGRID_from_Mentha, reviewed == 2)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
}
if(IMExdatabase == "X0469.IntAct."){
  whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha$species_name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha$species_name)
  library(dplyr)
  proteome_vs_interactome_summary.all_isof = filter(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, reviewed == 1)
  proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == FALSE)
  proteome_vs_interactome_summary.all_noisof = filter(whole_proteome_Uniprot_vs_IntAct_vs_BioGRID_from_Mentha, reviewed == 2)
  proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
}
library(VennDiagram)
{
grid.newpage()

plotname = paste0("Proteome coverage by interaction databases, overlap between ", IMExdatabase," and BioGRID")

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("UniprotKB, isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("SwissProt, isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("triple.venn.prot.R")
  venn = triple.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = TRUE)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("triple.venn.prot.R")
  venn = triple.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = TRUE)
  popViewport()
}
popViewport()
}
```

   Overall, BioGRID overlaps with IMEx to a large extent. Nonetheless, for all of the species we have looked at, BioGRID has annotated some proteins (and their interactions) which are not annotated in IMEx. BioGRID stores substantially more interactions for arabidopsis and quite a lot of human and mouse interactions.


##3. Mouse and human proteins are commonly combined for interaction experiments

   The fact that researchers tend to put proteins from other species (mostly human) into mouse experiments or tend to put mouse proteins into cells from other species (mostly human) is also common for interaction detection experiments and is clearly seen in figure 3: half of the mouse interactors are from the other species. This holds true both for IMEx databases (figure 3) and for BioGRID. However, this analysis doesn't show which proteins (mouse or human) were used as bait to capture interactions in which cells (mouse or human).

   Figure 3 also displays how many interactors do not have Uniprot identifiers - those are small molecules, RNA, DNA or a small fraction of proteins not mapped to UniProt. Big fraction of *C.elegans* interactors are coming from single experiment mapping transcription factors to their sites []

```{r IMEx_vs_Uniprot_N_Uniprot_Species, cache=F, fig.width=8, fig.height=8, fig.cap="Figure 3" }
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
isoforms = FALSE
### combine the summaries for multiple species of how many interactors have non-uniprot and non-given-species identifiers
interactome_identifiers_summary.all = data.frame()
  for (i in isoforms) {
    for(n in SPECIES_NAME) {
      filename.summary = paste("./summaries/","uniprotKB_IDs_and_",n,"_interactors_summary_isoforms_",i,"_",date,".txt", sep = "")
      if(!file.exists(filename.summary)) {
        interactome_identifiers_summary.all
      }
      if(file.exists(filename.summary)) {
        interactome_identifiers_summary.o = as.data.frame(fread(filename.summary, stringsAsFactors = F, data.table = F))
        interactome_identifiers_summary.all = rbind(interactome_identifiers_summary.all, interactome_identifiers_summary.o)
      }
    }
  }
interactome_identifiers_summary.all = unique(interactome_identifiers_summary.all)
## Plotting the number of interactors which have UniprotKB identifiers and belong to the species queried
interactome_identifiers_summary.all.s = interactome_identifiers_summary.all[,c(3,4,5,6,7)]
## Transform table for plotting with ggplot2
library(reshape2)
interactome_identifiers_summary.all.s.m= melt(data = interactome_identifiers_summary.all.s,
                                              id.vars = c("SPECIES_NAME", "SPECIES_ID"),
                                              variable.name = "decription",
                                              value.name = "number")
## rename yeast and E.coli
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain K12", "E. coli, strain K12", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Caenorhabditis elegans", "C. elegans", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Drosophila melanogaster", "D. melanogaster", interactome_identifiers_summary.all.s.m$SPECIES_NAME)

# filter out non-uniprot identifiers to make picture clearer
interactome_identifiers_summary.all.s.m$decription = gsub("\\.", " ", interactome_identifiers_summary.all.s.m$decription)
ind = interactome_identifiers_summary.all.s.m$decription != "interacting partners with the other identifier"
interactome_identifiers_summary.all.s.m = interactome_identifiers_summary.all.s.m[ind,]

# plot how many interactors have non-uniprot and non-given-species identifiers
library(ggplot2)
library(dplyr)
ggplot(interactome_identifiers_summary.all.s.m, aes(x=SPECIES_NAME, y=number, fill=decription)) + geom_bar(width = 0.9, stat = "identity", position = "stack") + geom_label(aes(label=number), position = "stack", size = 4, label.padding = unit(0.08, "lines")) +
  ggtitle("The number of interacting partners which have UniprotKB identifiers \n and belong to the species of interest") + theme(axis.text.x=element_text(angle = 20), axis.title.x = element_text(size = 0)) + ylab("number of proteins")
# save plot
# filename=paste("./results/", "interactome_identifiers_summary_plot_SMALL",date,".png", sep = "")
# ggsave(filename, proteome_vs_interactome_plot, width = 12, height = 12)
```

   Interchangeable use of mouse and human proteins generates interaction data which is hard to reuse and introduces imprecision due to the fact that it requires the mapping between homologous proteins. However, this may not be the biggest problem with studying the interactions between mouse and human proteins and trying to correctly interpret results. Recent studies of intrinsically disordered proteins show that linear amino acid motifs located in disordered regions frequently mediate protein-protein interactions [], for example, the disordered region of p53 mediates its ability to recruit transcription-activating proteins to the promoter []. More importantly, these linear amino acid motifs can evolve quickly, for example, allowing cancer cells to escape control by P53 []. So, while the interaction between mouse protein A and human protein B can exist, that might not be true for the interaction between human protein A and human protein B, and vice-verse.
   On the other hand, some researchers advocate that interactions important for the cellular function should be conserved between species [].

```{r dowlnload_all_IntAct, cache=F, fig.width=8}
# IntAct FTP contains the following databases = c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
#               "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")
# this will take time and data traffic ~ 2.5GB

url_intact = "ftp://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.txt"
filename_intact = paste0("./Data/IntAct_MITAB27_release_", format(Sys.Date(), "%m-%Y.txt"))
if(!file.exists(filename_intact)) {
  downloader::download(url_intact, filename_intact)
  }
# Read all IntAct
library(data.table)
all.IntAct = fread(filename_intact)
# changing column names to data.table-compatible format
{
(colnames_IntAct = colnames(all.IntAct))
colnames(all.IntAct) = gsub(" ","_",colnames(all.IntAct))
colnames(all.IntAct) = gsub("\\(|\\)","",colnames(all.IntAct))
colnames(all.IntAct) = gsub("#","",colnames(all.IntAct))
}
# cleaning Taxid "taxid:9606(human)|taxid:9606(Homo sapiens)" to 9606
all.IntAct = all.IntAct[,.(IDs_interactor_A, IDs_interactor_B, Experimental_roles_interactor_A, Experimental_roles_interactor_B,  Taxid_interactor_A, Taxid_interactor_B, Host_organisms, Publication_Identifiers, Confidence_values, Interaction_identifiers, Expansion_methods)]
{
all.IntAct[, Taxid_interactor_A := gsub("taxid:|\\(.*$","",Taxid_interactor_A)]
all.IntAct[, Taxid_interactor_B := gsub("taxid:|\\(.*$","",Taxid_interactor_B)]
all.IntAct[, Host_organisms := gsub("taxid:|\\(.*$","",Host_organisms)]
# saving identifier types and cleaning interactor ids
all.IntAct[, interactor_IDs_databases_A := gsub(":.*$","",IDs_interactor_A)]
all.IntAct[, interactor_IDs_databases_B := gsub(":.*$","",IDs_interactor_B)]
all.IntAct[, IDs_interactor_A := gsub("^.*:","",IDs_interactor_A)]
all.IntAct[, IDs_interactor_B := gsub("^.*:","",IDs_interactor_B)]
# cleaning other information
all.IntAct[, bait_prey_status_A := gsub("^.*\\(|\\)","",Experimental_roles_interactor_A)]
all.IntAct[, bait_prey_status_B := gsub("^.*\\(|\\)","",Experimental_roles_interactor_B)]
all.IntAct[, Publication_Identifiers := gsub("^.*pubmed:|\\|.*$","",Publication_Identifiers)]
all.IntAct[, Confidence_values := gsub("^intact-miscore:","",Confidence_values)]
all.IntAct[, Confidence_values := gsub("-","NA",Confidence_values)]
all.IntAct[, Confidence_values := as.numeric(Confidence_values)]
all.IntAct[, Interaction_identifiers := unlist(gsubfn::strapplyc(Interaction_identifiers,"EBI-[[:digit:]]+",simplify = T)), by =Interaction_identifiers]
}

# checking mixed mouse / human interactions
{
the_host_for_mouse_human_pairs = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb"
           , table(Host_organisms)]
the_host_for_mouse_human_pairs_mouse_as_bait = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey"))
           , table(Host_organisms)]
mouse_as_bait = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey")) &
              Host_organisms == "9606"
           ,.(IDs_interactor_A, IDs_interactor_B, Taxid_interactor_A, Taxid_interactor_B)]
mouse_as_bait_human_preys = length(unique(c(mouse_as_bait[(Taxid_interactor_A == "9606"), IDs_interactor_A], 
                mouse_as_bait[(Taxid_interactor_B == "9606"), IDs_interactor_B])))
mouse_as_bait_mouse_baits = length(unique(c(mouse_as_bait[(Taxid_interactor_A == "10090"), IDs_interactor_A], 
                mouse_as_bait[(Taxid_interactor_B == "10090"), IDs_interactor_B])))
N_pmid_mouse_as_bait_in_human = all.IntAct[((Taxid_interactor_A == "9606" & Taxid_interactor_B == "10090")  | 
                                               (Taxid_interactor_A == "10090" & Taxid_interactor_B == "9606")) &
             interactor_IDs_databases_A == "uniprotkb" & interactor_IDs_databases_B == "uniprotkb" &
            ((bait_prey_status_A == "prey" & bait_prey_status_B == "bait")  | 
                                               (bait_prey_status_A == "bait" & bait_prey_status_B == "prey")) &
              Host_organisms == "9606"
           ,length(unique(Publication_Identifiers))]
all.IntAct[Taxid_interactor_A == "9606" & Taxid_interactor_B == "9606", table(Host_organisms)]
}

```

   Surprisingly, `r the_host_for_mouse_human_pairs[["9606"]]` interactions between mouse and human proteins were discovered in human rather than mouse cells (only `r the_host_for_mouse_human_pairs[["10090"]]`) suggesting that researchers use mouse rather than human proteins as baits (`r mouse_as_bait_mouse_baits` mouse baits total, `r mouse_as_bait_human_preys` human preys total, including isoforms, from `r N_pmid_mouse_as_bait_in_human` publications) to find interactions directly relevant to human interactome research, including human disease.
   

## 4. Which proteins are missing interaction evidence?

   Characterising the properties of proteins missing interaction evidence can help prioritise curation efforts. By looking for proteins missing interaction evidence and involved in particular biological function (as described by Gene Ontology) or particular disease we can complete missing part of the interactome.

```{r human_not_in_IMEx_protein_properties_processing}
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
     ##============================================================================##
      ## querying Uniprot for the list of proteins (only mapped to Uniprot)
      ## downolading length, mass, SNPs, isoforms, annotation score, existence attribute
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      ## reading logic table and getting list of proteins
      if(n != "strain K12"){
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_vs_BioGRID_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")}
      if(n == "strain K12"){
      filename_vs_3 = paste("./analysis/","proteome_vs_interactome_f_", SPECIES_ID,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")}
      biogrid_from_mentha_vs_proteome_vs_imex_f = as.data.frame(read.delim(filename_vs_3, stringsAsFactors = F))
      source("download_whole_proteome.R")
      whole_proteome_query = download_whole_proteome(SPECIES_ID, date = date)
      colnames(whole_proteome_query)[2] = "Status"
      uniprot_query = dplyr::filter(whole_proteome_query, Status == "reviewed")
      ##============================================================================##
      ## merging information from Uniprot to the logic table
      proteome_vs_imex_details_f = merge(filter(biogrid_from_mentha_vs_proteome_vs_imex_f, whole_proteome_Uniprot==1), 
                                         uniprot_query, 
                                         by.x = "whole_proteome_IDs",
                                         by.y = "Entry")
      proteome_vs_imex_details_f$Mass = gsub(",","",proteome_vs_imex_details_f$Mass)
      proteome_vs_imex_details_f$Mass = as.numeric(proteome_vs_imex_details_f$Mass)
      ## creating a factor variable for presence_in_Uniprot.presence_in_IMEx (1_0/1_1)
      proteome_vs_imex_details_f[,length(proteome_vs_imex_details_f)+1] = interaction(proteome_vs_imex_details_f$whole_proteome_Uniprot, proteome_vs_imex_details_f$IMEx, sep = "_")
      colnames(proteome_vs_imex_details_f)[length(proteome_vs_imex_details_f)] = paste0(colnames(proteome_vs_imex_details_f)[2], "_","IMEx")
      levels(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx) = c("SwissProt_not_IMEX", "SwissProt_and_IMEX")
      ##============================================================================##
      ## saving combined logic table + protein properties from Uniprot
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      write.table(proteome_vs_imex_details_f,filename_vs_2,col.names=T,row.names=F,sep="\t",quote=F)
    }
  }
  }
```

### Olfactory receptors are a major group of human proteins not represented in IntAct



```{r human_not_in_IMEx_protein_properties_GO_BP, fig.width=10, fig.height=8}
##====================================================================
suppressPackageStartupMessages({
      library(data.table)
      library(qvalue)
      library(ggplot2)
      })
##====================================================================
# read the saved table
SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = fread(filename_vs_2, header = T, stringsAsFactors = F,quote="")
##====================================================================

      not_in_IMEx_BP = GO_enrich_simplify_plot_bioc(protein_set = unique(proteome_vs_imex_details_f[whole_proteome_Uniprot == 1 & IMEx == 0,whole_proteome_IDs]),
                                   reference_protein_set = unique(proteome_vs_imex_details_f[whole_proteome_Uniprot == 1,whole_proteome_IDs]),
                                   identifier_type = "UNIPROT", ontology = "BP", 
                                   pAdjustMethod_ = "BH", 
                                   minSetSize = 80, maxSetSize = 100, 
                                   simplify_by = "GeneRatio", 
                                   simplify_fun = "function (x) x[which.max(eval(parse(text = paste0(\"c(\",paste0(x, collapse = \",\"),\")\"))))]", 
                                   similarity_calc_method = "Wang", 
                                   similarity_cutoff = 0.7, 
                                   visualize_result = "dotplot", 
                                   above_corrected_pval = 0.05, 
                                   use_bioc_annotationdbi = T, 
                                   plot_title = "biological function of proteins with no available interactions in IMEx",
                                   xlabel = "the fraction of proteins with biological function among proteins without interactions")
      print(not_in_IMEx_BP$plot + theme(plot.title = element_text(hjust = 0.8)))
      
```

```{r human_not_in_IMEx_protein_properties_GO, fig.width=10, fig.height=8, eval=F}
semData <- clusterProfiler:::get_GO_data(OrgDb = 'org.Hs.eg.db', ont = "BP", keytype = "UNIPROT")
    # measure distance between selected terms (important to get all GO to protein mappings)
    semData = data.table(names(unlist(semData$EXTID2PATHID)),unlist(semData$EXTID2PATHID))
    colnames(semData) = c("UNIPROT","GO")
    semData = unique(semData)
    set.seed(1)
    semData = unique(semData[GO %in% semData[, unique(GO)][sample(1:40000,500)],])
    sim = categ_dist(mapping_table = semData)$similarity_matrix
```

```{r GO_enrichment_map, fig.height=10, fig.width=10, eval=F}
set.seed(6)
library(igraph)
x =enrichMap(enrichedGOterms, n = 40,layout = layout_with_kk, vertex.label.cex = 0.8,vertex.size = 5, rescale=T)
#plot(setting.graph.attributes(x, node.size = 5))
```

```{r new_go, fig.height=10, fig.width=10, eval=F}
source("GO_enrich_simplify_plot_bioc.R")
set.seed(1546)
new_depleted = GO_enrich_simplify_plot_bioc(protein_set = proteome_vs_imex_details_f[IMEx == 0 & whole_proteome_Uniprot == 1,unique(whole_proteome_IDs)],
                                            reference_protein_set = proteome_vs_imex_details_f[whole_proteome_Uniprot == 1,unique(whole_proteome_IDs)],
                                            identifier_type = "UNIPROT",
                                            ontology = "BP",
                                            pAdjustMethod_ = "fdr",
                                            minSetSize = 50,
                                            maxSetSize = 1000,
                                            simplify_by = "GeneRatio",
                                            simplify_fun = "function(x) eval(parse(text = x))",
                                            similarity_calc_method = "Wang",
                                            similarity_cutoff = 0.65,
                                            visualize_result = "enrichMap",
                                            above_corrected_pval = 0.05)
```


### Human proteins with no available interactions (from IMEx) are on average shorter than the proteins with interactions available  

   Protein length or mass are physical properties of a protein which can, in theory, influence it's usage as a bait in experiments and it's detection in case methods depend on protein length. Proteins length is also important biologically. Longer proteins can have multiple functional domains and, therefore, more interactions.
The distribution of protein mass has a very long right tail - there are much more big proteins than a normal distribution would predict (Supplementary figure 3), which only allows using non-parametric statistical tests (Wilcox test). Log10 transformation of protein mass, though, makes extreme values less extreme and is approximately normally distributed.

```{r human_not_in_IMEx_proteins_are_shorter_density, fig.width=7, fig.height=5, fig.cap="Figure 5" }
      ## Analysis
      # read the saved table
SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
      proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)
                  ## plotting the distribution of mass
      library(ggplot2)
      # ggplot(proteome_vs_imex_details_f, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.5)) +geom_density()+ scale_x_log10()
      # ggplot(proteome_vs_imex_details_f, aes(x = Mass, color = whole_proteome_Uniprot_IMEx, alpha =0.5)) + scale_x_log10() + geom_histogram(position = "identity", bins = 50)
      
      ## removing olfactory receptors:
      {proteome_vs_imex_details_f_minus_odor = proteome_vs_imex_details_f[-grep("Odor", 
                                                                                proteome_vs_imex_details_f$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf = proteome_vs_imex_details_f_minus_odor[-grep("Olfactory",
                                                                                              proteome_vs_imex_details_f_minus_odor$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf.c = rbind(cbind(proteome_vs_imex_details_f, olfac = 
                                                              rep("all SwissProt", nrow(proteome_vs_imex_details_f))),
                                                        cbind(proteome_vs_imex_details_f_minus_odor_olf, olfac = rep("SwissProt excluding \n olfactory receptors",nrow(proteome_vs_imex_details_f_minus_odor_olf))))}
      
      # the number of odor receptors excluded
n_odor_receptors = length(unique(grep("Odor", proteome_vs_imex_details_f$Protein.names, value = F))) + length(unique(grep("Olfactory", proteome_vs_imex_details_f_minus_odor$Protein.names, value = F)))

# calculating median per group
proteome_vs_imex_details_f_minus_odor_olf.c = as.data.table(proteome_vs_imex_details_f_minus_odor_olf.c)
proteome_vs_imex_details_f_minus_odor_olf.c[, whole_proteome_Uniprot_IMEx_x_olfac := paste0(whole_proteome_Uniprot_IMEx,olfac)]
proteome_vs_imex_details_f_minus_odor_olf.c[, median_Mass_per_group := median(log10(Mass)), by = whole_proteome_Uniprot_IMEx_x_olfac]
proteome_vs_imex_details_f_minus_odor_olf.c[, in_IMEx := ifelse(whole_proteome_Uniprot_IMEx == "SwissProt_and_IMEX", "yes", "no")]
          ## histogram with and without olfactory receptors:
      ggplot(proteome_vs_imex_details_f_minus_odor_olf.c, aes(x = Mass, color = in_IMEx, label = olfac)) +geom_freqpoly(bins = 100)+ scale_x_log10() + theme(strip.text.y = element_text(angle = 0)) +xlab("protein mass, Da, log10 scale") + ggtitle("The distribution of protein mass for proteins with and \n without interacting partners curated in IMEx")+geom_vline(aes(xintercept = 10^median_Mass_per_group, color = in_IMEx),alpha =0.7)  + facet_grid(olfac~.)+
 theme(panel.background = element_rect(fill = '#FFFFFF', colour = 'grey'))
      
      # for poster
      proteome_vs_imex_details_f_minus_odor_olf.c_post = proteome_vs_imex_details_f_minus_odor_olf.c[olfac == "all SwissProt",]
      proteome_vs_imex_details_f_minus_odor_olf.c_post[,Organism := gsub(" \\(Human\\)","",Organism)]
      protein_mass = ggplot(proteome_vs_imex_details_f_minus_odor_olf.c_post, aes(x = Mass, color = in_IMEx, label = Organism)) +
        geom_freqpoly(bins = 100)+ scale_x_log10() + 
        theme(strip.text.y = element_text(angle = 0)) +
        xlab("protein mass, Da, log10 scale") + 
        ggtitle("Mass of proteins with and without \n interacting partners curated in IMEx")+
        facet_grid(Organism~.) + 
        geom_vline(aes(xintercept = 10^median_Mass_per_group, color = in_IMEx),alpha =0.7,size =1.5) +
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```

```{r human_not_in_IMEx_proteins_are_shorter_Wilcox}
           ## testing the difference in protein mass distributions
            ##of proteins absent/present in IMEx using Wilcox rank test
      SwissProt_not_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
      wilcox.test.r = wilcox.test(SwissProt_not_IMEX, SwissProt_and_IMEX, conf.int = T)
      ttest_r = t.test(log10(SwissProt_not_IMEX), log10(SwissProt_and_IMEX), conf.int = T)
                 ## testing the difference in protein mass distributions after removing odor receptors
            ##of proteins absent/present in IMEx using Wilcox rank test excluding olfactory receptors
      SwissProt_not_IMEX = proteome_vs_imex_details_f_minus_odor_olf$Mass[proteome_vs_imex_details_f_minus_odor_olf$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f_minus_odor_olf$Mass[proteome_vs_imex_details_f_minus_odor_olf$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
      wilcox.test.r.min.olf = wilcox.test(SwissProt_not_IMEX, SwissProt_and_IMEX, conf.int = T)
```

This difference in protein mass between proteins present and absent in the interactome is highly unlikely to occur by chance (Wilcox rank test (Mass, Da, 95% confidence interval: `r signif(wilcox.test.r$conf.int,3)`, p-value: `r signif(wilcox.test.r$p.value,3)`) and Student t-test(log10 of Mass, Da, 95% confidence interval: `r signif(ttest_r$conf.int,3)`, p-value: `r signif(ttest_r$p.value,3)`) on the whole population of proteins, Monte-Carlo sampling (is it useful?), permutation of labels followed by Wilcox rank test (is it useful?) - Supplementary figure 3,4,5). Removing `r signif(n_odor_receptors,3)` olfactory receptors, evidently, does not change this trend (Wilcox rank test on Mass, Da, 95% confidence interval: `r signif(wilcox.test.r.min.olf$conf.int,3)`, p-value: `r signif(wilcox.test.r.min.olf$p.value,3)`).

### Major experimental role types (bait/prey/neutral component) are not substantially influenced by the mass of the protein

The experimental role of the protein (bait/prey/neutral component) can, in theory, be influenced by protein mass. For example, it may be easier to clone shorter proteins for use as bait/prey. So it important to see if the experimental role is really influenced by protein mass.

```{r human_not_in_IMEx_bait_vs_non_bait, fig.width=8, fig.height=5, fig.cap="Figure 5" }
bait_vs_non_bait = copy(all.IntAct[,.(IDs_interactor_A, IDs_interactor_B, Taxid_interactor_A, Taxid_interactor_B, bait_prey_status_A,bait_prey_status_B,interactor_IDs_databases_A,interactor_IDs_databases_B)])
proteome_vs_imex_details_f = as.data.table(proteome_vs_imex_details_f)
# Length for interactor A, implicit filtering: proteins only and species human due to the data.frame "proteome_vs_imex_details_f" contents
bait_vs_non_bait = merge(bait_vs_non_bait, proteome_vs_imex_details_f[, .(whole_proteome_IDs, Mass)], by.x = "IDs_interactor_A", by.y = "whole_proteome_IDs", all.y = F, all.x = F)
# Length for interactor B, implicit filtering: proteins only and species human due to the data.frame "proteome_vs_imex_details_f" contents
bait_vs_non_bait = merge(bait_vs_non_bait, proteome_vs_imex_details_f[, .(whole_proteome_IDs, Mass)], by.x = "IDs_interactor_B", by.y = "whole_proteome_IDs", all.y = F, all.x = F)
# interactions to interactors
bait_vs_non_bait = bait_vs_non_bait[, data.table(IDs_interactor = c(IDs_interactor_A, IDs_interactor_B), 
                                                 bait_prey_status = as.character(c(bait_prey_status_A,bait_prey_status_B)),
                                                 Mass = c(Mass.x, Mass.y),
                                                 interactor_IDs_databases = c(interactor_IDs_databases_A,
                                                                              interactor_IDs_databases_B))]
bait_vs_non_bait = unique(bait_vs_non_bait)
# getting bait-prey status to separate columns: spreading data.table
# bait_vs_non_bait = dcast(bait_vs_non_bait, IDs_interactor + Mass + interactor_IDs_databases ~ bait_prey_status, value.var = "bait_prey_status",fill ="") # too many experimental role types for combinations
bait_vs_non_bait[,median_log10_mass_per_role := median(log10(Mass)), by = bait_prey_status]
bait_vs_non_bait[,N_bait_prey_status := .N, by = bait_prey_status]
bait_vs_non_bait[,bait_prey_status_label := paste(bait_prey_status,", N =", N_bait_prey_status)]

ggplot(bait_vs_non_bait, aes(x = Mass, color = bait_prey_status)) +geom_density(bins = 100)+ scale_x_log10() + facet_grid(bait_prey_status_label~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("protein mass, Da, log10 scale") + ggtitle("the distribution density of protein mass grouped by experimental role \n (for proteins in IMEx)") +geom_vline(aes(xintercept = 10^median_log10_mass_per_role, color = bait_prey_status))
```
 
 
   We can now select only the most frequent experimental roles

```{r human_not_in_IMEx_bait_vs_non_bait2, fig.width=8, fig.height=5, fig.cap="Figure 5" }
bait_vs_non_bait = bait_vs_non_bait[N_bait_prey_status > 1000,]
ggplot(bait_vs_non_bait, aes(x = Mass, color = bait_prey_status_label)) +geom_density(bins = 100)+ scale_x_log10()  + theme(strip.text.y = element_text(angle = 0)) +xlab("protein mass, Da, log10 scale") + ggtitle("the distribution density of protein mass grouped by experimental role \n (for proteins in IMEx)") +geom_vline(aes(xintercept = 10^median_log10_mass_per_role, color = bait_prey_status_label))

```

   Evidently, the experimental role of a protein is not substantially influenced by the mass of the protein.


### Most of the human proteins with no available interactions (from IMEx databases) are membrane proteins

   coming soon

### If a protein is missing protein evidence in Uniprot it is also more likely to be missing from IMEx databases

   coming soon

```{r not_in_imex_missing_protein_evidence}

```


## 5. Proteins missing interaction evidence are not associated with specific disease


```{r disease_enrichment}
# ===================================================
# read the saved table
SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = as.data.table(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
      proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)


### DisGnet
      # mapping UniprotID to entrezgene id using UniProt.ws for DisGnet enrichment using enrichDGN() from DOSE
      #loading UniProt.ws functionality
library(UniProt.ws)
uniprot = UniProt.ws(taxId = 9606)
# getting names of the things one can get from UniProt.ws
# keytypes(uniprot)
uniprot2entrezgene = as.data.table(select(uniprot, 
               keys = unique(proteome_vs_imex_details_f$whole_proteome_IDs), 
               columns = c("ENTREZ_GENE", "UNIPROTKB"),
               keytype = "UNIPROTKB"))
uniprot2entrezgene = copy(uniprot2entrezgene[complete.cases(uniprot2entrezgene),])
colnames(uniprot2entrezgene) = c("uniprot_swissprot","entrezgene")
# Mapping ID to the other info in the table
proteome_vs_imex_details_f = merge(x = proteome_vs_imex_details_f, y = uniprot2entrezgene, 
                                   by.x = "whole_proteome_IDs",
                                   by.y = "uniprot_swissprot",
                                   all.x = T, all.y = F)
# define function which does enrichment
uniprot2enrichedDiseases = function(my_protein_set_entrez, reference_set_entrez){
  suppressPackageStartupMessages({
      library(DOSE)})
ego <-  enrichDGN(gene = as.character(my_protein_set_entrez), 
                                               pvalueCutoff = 1, pAdjustMethod = "BH", 
                                               universe = as.character(reference_set_entrez), 
                                               minGSSize = 10, maxGSSize = 500, qvalueCutoff = 1, readable = FALSE)
# ego_sorted = as.data.table(as.data.frame(ego)[order(as.data.frame(ego)$p.adjust),])
}
enrichedDiseases = uniprot2enrichedDiseases(
  my_protein_set = proteome_vs_imex_details_f[IMEx == 0 & whole_proteome_Uniprot == 1,entrezgene],
  reference_set = proteome_vs_imex_details_f[whole_proteome_Uniprot == 1,entrezgene]
  )


```


```{r disease_enrichment_map, fig.height=20, fig.width=20}
enrichMap(enrichedDiseases)
```

## 5. Do major protein interaction detection methods (two-hybrid and AP-MS) exhibit a bias towards biochemical properties of the proteins?

   The problem of bias in interactomics is often discussed in research papes and in the community. Now we will focus on the bias of the experimental detection methods. We choose to compare two major families of methods: two-hybrid and affinity-purification-mass-spectrometry (AP-MS). 
   We identify two-hybrid method using PSI-MI ontology: detection method = "transcriptional complementation assay" (MI:0018) - all methods which belong to this type (which are children terms in the ontology). We identify AP-MS method using two PSI-MI ontology terms: detection method = "affinity chromatography technology" (MI:0004) and participant identification method = "partial identification of protein sequence" (MI:0433). The use of ontology terms for searching interaction allows to only specify a single term as opposed to listing every indivudual detection method included in those groups. One can browse ontology lookup service to identify which exact approaches are included under the umbrella of two-hybrid or affinity-purification-mass-spectrometry.  
   We fetch interactions detected using these methods by querying molecular interaction databases using PSICQUIC service.

### AP-MS is biased towards longer proteins

   Unlike the experimental role type, whether a protein interaction is detected using a particular interaction detection method is influenced by the mass of that protein.

```{r querying_PSICQUIC_cleaning_and_transforming_interaction_types}

SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", SPECIES_NAME,"_reviewed_",reviewed,"_isoforms_",isoforms,"_", date,".txt", sep = "")
if(mean(file.exists(filename)) != 1){
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID
      

databases <- c("IntAct", "MINT", "bhf-ucl", "MPIDB", "MatrixDB", 
               "HPIDb","I2D-IMEx","InnateDB-IMEx", "MolCon", "UniProt", "MBInfo")

source("query_PSICQUIC_for_interactions.R")
twohybrids_all_interactions = query_PSICQUIC_for_interactions(SPECIES_ID = SPECIES_ID, 
                                                   SPECIES_NAME = n, 
                                                   databases = databases, date,
                                                   detmethod = "%22MI:0018%22") # %22 is a code for quote
complementation_all_interactions = query_PSICQUIC_for_interactions(SPECIES_ID = SPECIES_ID, 
                                                              SPECIES_NAME = n, 
                                                              databases = databases, date,
                                                              detmethod = "%22MI:0090%22")
ap_ms_all_interactions = query_PSICQUIC_for_interactions(SPECIES_ID = SPECIES_ID, 
                                                         SPECIES_NAME = n, 
                                                         databases = databases, date,
                                                         detmethod = "%22MI:0004%22",
                                                         pmethod = "%22MI:0433%22")

##=========================================================##
# extracting interactor ID-s from interactions (MI-TAB 2.7)
source("interactions_to_interactors.R")
twohybrids_all_interactors = interactions_to_interactors(twohybrids_all_interactions)
complementation_all_interactors = interactions_to_interactors(complementation_all_interactions)
ap_ms_all_interactors = interactions_to_interactors(ap_ms_all_interactions)

# filtering interactors for uniprotkb only indentifiers 
# filtering for SPECIES_ID only proteins
source("uniprotkb_and_SPECIES_ID_interactor_selector.R")
twohybrids_all_interactors_SPECIES_ID_only = uniprotkb_and_SPECIES_ID_interactor_selector(twohybrids_all_interactors, SPECIES_ID)
complementation_all_interactors_SPECIES_ID_only = uniprotkb_and_SPECIES_ID_interactor_selector(complementation_all_interactors, SPECIES_ID)
ap_ms_all_interactors_SPECIES_ID_only = uniprotkb_and_SPECIES_ID_interactor_selector(ap_ms_all_interactors, SPECIES_ID)

# Removing all isoform IDs (XXXXXX-X+ => XXXXXX) from IDs
  source("isoform_id_all_remover.R")
  twohybrids_all_interactors_SPECIES_ID_only$interactor_IDs = isoform_id_all_remover(twohybrids_all_interactors_SPECIES_ID_only$interactor_IDs)
  complementation_all_interactors_SPECIES_ID_only$interactor_IDs = isoform_id_all_remover(complementation_all_interactors_SPECIES_ID_only$interactor_IDs)
  ap_ms_all_interactors_SPECIES_ID_only$interactor_IDs = isoform_id_all_remover(ap_ms_all_interactors_SPECIES_ID_only$interactor_IDs)
  
# preparing interaction detection method data for logic table: selecting unique proteins and adding the column of ones
unique_twohybrids_interactors_SPECIES_ID_only = unique(cbind(twohybrids_all_interactors_SPECIES_ID_only[c("interactor_IDs")], 1))
colnames(unique_twohybrids_interactors_SPECIES_ID_only)[2] = "two_hybrid"
unique_complementation_interactors_SPECIES_ID_only = unique(cbind(complementation_all_interactors_SPECIES_ID_only[c("interactor_IDs")], 1))
colnames(unique_complementation_interactors_SPECIES_ID_only)[2] = "all_protein_complementation"
unique_ap_ms_interactors_SPECIES_ID_only = unique(cbind(ap_ms_all_interactors_SPECIES_ID_only[c("interactor_IDs")], 1))
colnames(unique_ap_ms_interactors_SPECIES_ID_only)[2] = "AP_MS"

# loading logic table made by "swissprot_vs_imex_protein_properties" script or by 
filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)

# merging new results with the logic table
proteome_vs_imex_interaction_details_t1 = merge(proteome_vs_imex_details_f, 
                                   unique_twohybrids_interactors_SPECIES_ID_only, 
                                   by.x = "whole_proteome_IDs",
                                   by.y = "interactor_IDs",
                                   all.x = T, all.y = F)
proteome_vs_imex_interaction_details_t2 = merge(proteome_vs_imex_interaction_details_t1, 
                                               unique_complementation_interactors_SPECIES_ID_only, 
                                               by.x = "whole_proteome_IDs",
                                               by.y = "interactor_IDs",
                                               all.x = T, all.y = F)
proteome_vs_imex_interaction_details_f = merge(proteome_vs_imex_interaction_details_t2, 
                                               unique_ap_ms_interactors_SPECIES_ID_only, 
                                                by.x = "whole_proteome_IDs",
                                                by.y = "interactor_IDs",
                                                all.x = T, all.y = F)
proteome_vs_imex_interaction_details_f[is.na(proteome_vs_imex_interaction_details_f)] = 0

# adding factor combination variable - two_hybrid and AP_MS
proteome_vs_imex_interaction_details_f[,length(proteome_vs_imex_interaction_details_f)+1] = interaction(proteome_vs_imex_interaction_details_f$two_hybrid, proteome_vs_imex_interaction_details_f$AP_MS, sep = "_")
colnames(proteome_vs_imex_interaction_details_f)[length(proteome_vs_imex_interaction_details_f)] = paste0("two_hybrid", "_vs_","AP_MS")
levels(proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS) = c("not two-hybrid, and not AP-MS", "two-hybrid, not AP-MS","not two-hybrid, AP-MS", "two-hybrid and AP-MS")
proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS = as.character(proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS)
proteome_vs_imex_interaction_details_f$two_hybrid_vs_AP_MS[proteome_vs_imex_interaction_details_f$IMEx!=1] = "not in IMEx"

# saving combined logic table with protein properties from Uniprot and interaction properties combined
filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
write.table(proteome_vs_imex_interaction_details_f,filename,col.names=T,row.names=F,sep="\t",quote=F)
    }
  }
}
}
```

```{r interaction_types_combine_and_plot,  fig.width = 9, fig.height = 7, fig.cap= "Figure 6"}
# read the table saved before 
library(rafalib)
library(MASS)
library(RColorBrewer)
library(multcomp)
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
proteome_vs_imex_interaction_details_all = data.table()
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_interaction_details_f = as.data.table(fread(filename, header = T, stringsAsFactors = F,quote="", data.table = F))
n = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", n)
n = gsub("strain K12", "Escherichia coli, strain K12", n)
proteome_vs_imex_interaction_details_f[ , c("SPECIES_NAME","reviewed","isoforms", "SPECIES_ID") := list(n,r,i,SPECIES_ID)]
proteome_vs_imex_interaction_details_all = rbind(proteome_vs_imex_interaction_details_all,proteome_vs_imex_interaction_details_f, fill =T)
    }}}

proteome_vs_imex_interaction_details_all$two_hybrid_vs_AP_MS = factor(proteome_vs_imex_interaction_details_all$two_hybrid_vs_AP_MS, levels = c("not in IMEx", "not two-hybrid, and not AP-MS", "two-hybrid, not AP-MS", "not two-hybrid, AP-MS", "two-hybrid and AP-MS"))

proteome_vs_imex_interaction_details_all[, Median_mass := median((Mass)), by = .(SPECIES_NAME,two_hybrid_vs_AP_MS)]

proteome_vs_imex_interaction_details_all[,plot_labels := (paste0(gsub("_"," ",two_hybrid_vs_AP_MS),", (median mass: ", signif(Median_mass/1000,3)," kDa)"))]
proteome_vs_imex_interaction_details_all[,plot_labels := (paste0(signif(Median_mass/1000,3)," kDa)"))]

library(scales)
proteome_vs_imex_interaction_details_human = proteome_vs_imex_interaction_details_all[SPECIES_NAME == "Homo sapiens",]
ggplot(proteome_vs_imex_interaction_details_human, aes(y = Mass, x =two_hybrid_vs_AP_MS, fill = two_hybrid_vs_AP_MS)) +
  geom_violin(draw_quantiles = c(0.05,0.25,0.495,0.5,0.505,0.75,0.95),scale = "area", alpha =0.7) +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) + geom_vline(aes(colour = two_hybrid_vs_AP_MS,xintercept = Median_mass)) +
  ylab("Mass, Da, log10 scale")+
  xlab("in IMEx, interaction detection method")+
  ggtitle("How does protein interaction detection method depend on the protein length?")+facet_grid(.~SPECIES_NAME)+theme(axis.text.x = element_text(angle =-35))+
   theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),panel.background = element_rect(fill = '#FFFFFF', colour = 'grey'))
```

   The statistical significance of the difference in protein mass across protein detection methods was tested using linear model approach. Linear model offers way to perform multiple statistical tests (ANOVA and posthoc ttests) in R. Linear model takes a group assignment for a protein (only two-hybrid, only AP-MS, both two-hybrid and AP-MS, other methods - a vector 0s and 1s where 1 show which group a protein belongs to) and the mass of that protein. Using these parameters for each of the proteins linear model can learn the mean of each group as well as provide a way to calculate errors for each of the between-group comparisons. The robust linear model used for this test is less sensitive to the extreme values.
   The results of statistical tests can be visualised on a plot. In the box plot below, each vertical arrow points to the mean mass of the proteins in a particular group. The middle line of the boxplot represents a median which happens to coincide with mean because the distribution of logarithm base 10 of mass is approximately normally distributed.
   Each yellow arrow shows the p-value and the difference in protein mass between two corresponding groups.

```{r protein_length_det_method_rlm,  fig.width = 10, fig.height = 8, fig.cap= "Figure 7. Does rlm require normally distributed data?"}
## linear model code below
# ============================================

# IMEx_two_hybrid_AP_MS
mypar(2,2)
for(sp in SPECIES_NAME){
sp = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", sp)
sp = gsub("strain K12", "Escherichia coli, strain K12", sp)
data = proteome_vs_imex_interaction_details_all[two_hybrid_vs_AP_MS != "not in IMEx" & SPECIES_NAME == sp,]
fit_rlm = rlm(log10(Mass)~two_hybrid_vs_AP_MS, data = data)
coefs <- coef(fit_rlm)
names(coefs) = data[,sort(unique(two_hybrid_vs_AP_MS))]

## Visual explanation
a <- -0.25
lgth <- .1
cols <- brewer.pal(8,"Dark2")

boxplot(log10(Mass)~two_hybrid_vs_AP_MS, data = data, 
           vertical=TRUE, pch=1, method="jitter",las=1,cex.axis= 0.80, main = paste0(sp, ": protein length vs interaction detmethod, rlm"), cex.main=0.99)
abline(h=0)
arrows(1+a,0,1+a,coefs[1],lwd=3,col=cols[1],length=lgth)
abline(h=coefs[1],col=cols[1])
#AP_MS
arrows(2+a,coefs[1],2+a,coefs[1]+coefs[2],lwd=3,col=cols[2],length=lgth)
segments(2+2*a,coefs[1]+coefs[2],2-2*a,coefs[1]+coefs[2],col=cols[2])
#two-hybrid and #AP_MS
arrows(3+a,coefs[1],3+a,coefs[1]+coefs[3],lwd=3,col=cols[3],length=lgth)
segments(3+2*a,coefs[1]+coefs[3],3-2*a,coefs[1]+coefs[3],col=cols[2])
#two-hybrid
arrows(4+a,coefs[1],4+a,coefs[1]+coefs[4],lwd=3,col=cols[4],length=lgth)
segments(4+2*a,coefs[1]+coefs[4],4-2*a,coefs[1]+coefs[4],col=cols[2])

# two_hybrid vs AP_MS significance testing
C <- matrix(c(0,1,0,-1),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[2] - coefs[4])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[1]+coefs[2]
estimate_2 = coefs[1]+coefs[4]
arrows(2,estimate_1-0.3,4,estimate_2-0.3,lwd=3,col=cols[6],length=lgth)
text(3,(estimate_1-0.35 + estimate_2-0.35)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# two_hybrid vs AP_MS_and_two_hybrid significance testing
C <- matrix(c(0,0,1,-1),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[3] - coefs[4])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[1]+coefs[3]
estimate_2 = coefs[1]+coefs[4]
arrows(3,estimate_1+0.3,4,estimate_2+0.3,lwd=3,col=cols[6],length=lgth)
text(3.5,(estimate_1+0.35 + estimate_2+0.35)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# other_methods vs AP_MS significance testing
C <- matrix(c(0,1,0,0),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[2])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[2]+coefs[1]
estimate_2 = coefs[1]
arrows(2,estimate_1-0.4,1,estimate_2-0.4,lwd=3,col=cols[6],length=lgth)
text(1.5,(estimate_1-0.45 + estimate_2-0.45)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# other_methods vs AP_MS_and_two_hybrid significance testing
C <- matrix(c(0,0,1,0),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[3])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[3]+coefs[1]
estimate_2 = coefs[1]
arrows(3,estimate_1+0.4,1,estimate_2+0.4,lwd=3,col=cols[6],length=lgth)
text(2.5,(estimate_1+0.45 + estimate_2+0.45)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)
# AP_MS vs AP_MS_and_two_hybrid significance testing
C <- matrix(c(0,-1,1,0),1)
two_hybridvsAP_MS <- glht(fit_rlm, linfct=C)
Sigma.hat = two_hybridvsAP_MS$vcov
SE = sqrt(C %*% Sigma.hat %*% t(C))
difference = abs(coefs[3]-coefs[2])
p_val = pnorm(difference/SE,lower.tail = F)*2
estimate_1 = coefs[3]+coefs[1]
estimate_2 = coefs[1]+coefs[2]
arrows(3,estimate_1+0.7,2,estimate_2+0.7,lwd=3,col=cols[6],length=lgth)
text(2.5,(estimate_1+0.75 + estimate_2+0.75)/2,paste("p-value: ",signif(p_val,2),"\n diff.: ",signif((10^estimate_1 - 10^estimate_2)/1000,2)," kDa"),cex =0.9)

legend("topright",names(coefs),fill=cols,cex=.75,bg="white")
}
```

   The figure X shows that the mass of the proteins which were identified interacting using AP-MS technique is on average higher that the mass of the proteins identified using two-hybrid or the other methods.

## 6. The number of interactions (or MI score) is associated with the number of publications

   The problem of better-studied proteins having more interactions despite all proteins having similar amounts of Mendelian-type mutations and therefore similar functional significance has been discussed in the literature a few years ago []. So we decided to have a fresh look and explore the problem more deeply.
   Interaction is defined by two proteins which form it regardless of how many times these proteins were spotted interacting. MI score is an empirical score proposed by IMEx consortium to evaluate the evidence that supports each given interaction []. Not every interaction has enough evidence to get an MI score. We have counted the number of interactions for each protein (Figure 8) and summed MI scores over interactions for each protein (Figure 9, this can be seen as the number of interactions combined with the confidence we have for their existence). We define a large-scale study as a study which provided more than 100 interactions in IntAct (counting by interaction identifiers).
   The number of publications per gene was counted using NCBI gene to PubMed ID conversion table.
   
   
```{r UniprotAC_to_geneID_start}
{
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
SPECIES_IDs = character()
source("SPECIES_NAME_TO_ID.R")
count = 1
for(species in SPECIES_NAME) {
  x = SPECIES_NAME_TO_ID(species)
  SPECIES_IDs[count] = x$SPECIES_ID
  count = count+1
  rm(list = "x")
}
}
## Converting UniprotAC to geneID
## Converting UniprotAC isoforms to generic
{
all.IntAct[,IDs_interactor_A_isoforms := IDs_interactor_A]
all.IntAct[,IDs_interactor_B_isoforms := IDs_interactor_B]
source("isoform_id_all_remover.R")
all.IntAct[interactor_IDs_databases_A == "uniprotkb", IDs_interactor_A := isoform_id_all_remover(IDs_interactor_A)]
all.IntAct[interactor_IDs_databases_B == "uniprotkb", IDs_interactor_B := isoform_id_all_remover(IDs_interactor_B)]
}

## Uniprot to geneID mapping 
#downloading the content of the folder containing species specific ID mapping

{# generating filenames
library(RCurl)
uniprotAC2geneID_url = "ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/"
filenames <- getURL(uniprotAC2geneID_url, dirlistonly = TRUE) 
filenames = unlist(strsplit(filenames,"\n"))
filenames = filenames[grep("idmapping.dat.gz",filenames)]
uniprotAC2geneID_filename = paste0("./Data/uniprotAC2geneID","release_", format(Sys.Date(), "%m-%Y"),"_", filenames)
uniprotAC2geneID_filename.dat = substr(uniprotAC2geneID_filename, 1, nchar(uniprotAC2geneID_filename)-3)
}
# downloading and unzipping mapping files
for(i in 1:length(uniprotAC2geneID_filename.dat)){
  if(!file.exists(uniprotAC2geneID_filename.dat[i])) {
    downloader::download(paste0(uniprotAC2geneID_url,filenames[i]), uniprotAC2geneID_filename[i])
  R.utils::gunzip(uniprotAC2geneID_filename[i])
}
}
# reading files for uniprotAC to geneID mapping
uniprotAC2geneID = data.table()
for(i in 1:length(uniprotAC2geneID_filename.dat)){
  temp = fread(uniprotAC2geneID_filename.dat[i], header = F)
  temp = temp[V2 == "GeneID", .(V1, V3)]
  uniprotAC2geneID = rbind(uniprotAC2geneID,temp)
  rm(list = "temp")
}

## copy all.IntAct (data.table doesn't make an explicit copy while assigning DT = data.table())
all.IntAct.modif = copy(all.IntAct)
## map GeneIDs for IDs_interactor_A
{
colnames(uniprotAC2geneID)[2] = "IDs_interactor_A_GeneID"
all.IntAct.modif = merge(x=all.IntAct.modif, y=uniprotAC2geneID, by.x = "IDs_interactor_A", by.y = "V1", all.x=TRUE, all.y = F)
}
## map GeneIDs for IDs_interactor_B
{
colnames(uniprotAC2geneID)[2] = "IDs_interactor_B_GeneID"
all.IntAct.modif = merge(x=all.IntAct.modif, y=uniprotAC2geneID, by.x = "IDs_interactor_B", by.y = "V1", all.x=TRUE, all.y = F)
rm(list = "uniprotAC2geneID")
}
```

```{r GeneID_to_publication_IDs}
## getting the publication ID for each gene
{
geneID2pubmed_url = "ftp://ftp.ncbi.nih.gov/gene/DATA/gene2pubmed.gz"
geneID2pubmed_filename = paste0("./Data/geneID2pubmed_release_", format(Sys.Date(), "%m-%Y.gz"))
geneID2pubmed_filename_txt = substr(geneID2pubmed_filename, 1, nchar(geneID2pubmed_filename)-3)
if(!file.exists(geneID2pubmed_filename_txt)) {
  downloader::download(geneID2pubmed_url, geneID2pubmed_filename)
  R.utils::gunzip(geneID2pubmed_filename)
}
}

## count the number of pubmed PMID per GeneIDs for IDs_interactor_A and B
{
geneID2pubmed = fread(geneID2pubmed_filename_txt, colClasses = c("character","character","character"))
geneID2pubmed = geneID2pubmed[,.(GeneID, PubMed_ID)]

geneID2pubmed[, interactor_A_total_PMID := length(PubMed_ID), by = GeneID]
geneID2pubmed = geneID2pubmed[,unique(data.table(GeneID,interactor_A_total_PMID))][,GeneID := as.character(GeneID)]
all.IntAct.modif = merge(all.IntAct.modif, geneID2pubmed, by.x = "IDs_interactor_A_GeneID", by.y = "GeneID", all.x=TRUE)
colnames(geneID2pubmed)[2] = "interactor_B_total_PMID"
all.IntAct.modif = merge(all.IntAct.modif, geneID2pubmed, by.x = "IDs_interactor_B_GeneID", by.y = "GeneID", all.x=TRUE)
 colnames(all.IntAct.modif)
 rm(list = "geneID2pubmed")
}


# Count the number of interactions per publication
{
all.IntAct.modif[,unique_interactions := apply(data.table(IDs_interactor_A,IDs_interactor_B,stringsAsFactors = F), 1,
                                               function(a) { z = sort(a)
                                               paste0(z[1],"_",z[2]) })]
all.IntAct.modif[,unique_interactions_per_Publication := length(unique(unique_interactions)), by = Publication_Identifiers]
all.IntAct.modif[,interaction_ids_per_Publication := length(unique(Interaction_identifiers)), by = Publication_Identifiers]
all.IntAct.modif[Expansion_methods != "psi-mi:\"MI:1060\"(spoke expansion)",unique_interactions_per_Publication_nospoke := length(unique(unique_interactions)),
                 by = Publication_Identifiers]
all.IntAct.modif[Expansion_methods != "psi-mi:\"MI:1060\"(spoke expansion)", interaction_ids_per_Publication_nospoke := length(unique(Interaction_identifiers)), by = Publication_Identifiers]
}
```

```{r count_n_interactions_per_protein}
# Count the number of unique interactions (interacting partners) (by UniprotID)
{
  # Counting UniprotID
all.IntAct.modif[,unique_interactions_per_interactor_A := length(unique(grep(IDs_interactor_A, unique_interactions ,value = T))), by = IDs_interactor_A]

all.IntAct.modif[,unique_interactions_per_interactor_B := length(unique(grep(IDs_interactor_B, unique_interactions ,value = T))), by = IDs_interactor_B]
}
# Count the number of interaction IDs (by UniprotID)
{
  # Counting IntAct interaction IDs
all.IntAct.modif[,N_interaction_IDs_per_interactor_A := length(unique(Interaction_identifiers)), by = IDs_interactor_A]

all.IntAct.modif[,N_interaction_IDs_per_interactor_B := length(unique(Interaction_identifiers)), by = IDs_interactor_B]
}
```

```{r large_scal_small_scale_threshold}
# tag interactions by the scale of the study
{
# tagging interactons
all.IntAct.modif[,large_scale := ifelse(interaction_ids_per_Publication > 100, "large_scale", "small_scale")]
}

# save tables for separate MI score calculation in large-scale vs small-scale studies (threshold 100):
scale_of_study_files = c(paste0("./Data/small_scale_100_",format(Sys.Date(),"%m_%y"),"_all_IntAct.txt"),paste0("./Data/large_scale_100_",format(Sys.Date(),"%m_%y"),"_all_IntAct.txt"))
if(mean(file.exists(paste0(scale_of_study_files,".gz"))) != 1){
small_scale_dat = copy(all.IntAct)
{
small_scale_dat[,interaction_ids_per_Publication := length(unique(Interaction_identifiers)), by = Publication_Identifiers]
small_scale.index = small_scale_dat$interaction_ids_per_Publication < 100
large_scale.index = small_scale_dat$interaction_ids_per_Publication >= 100
rm(small_scale_dat)
}

{
url_intact = "ftp://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.txt"
filename_intact = paste0("./Data/IntAct_MITAB27_release_", format(Sys.Date(), "%m-%Y.txt"))
if(!file.exists(filename_intact)) {
  downloader::download(url_intact, filename_intact)
  }
# Read all IntAct
library(data.table)
all.IntAct.tab = fread(filename_intact)

fwrite(all.IntAct.tab[small_scale.index,],
       file = scale_of_study_files[1], 
       sep = "\t", col.names = TRUE, quote=F)
fwrite(all.IntAct.tab[large_scale.index,],
       file = scale_of_study_files[2], 
       sep = "\t", col.names = TRUE, quote=F)
R.utils::gzip(scale_of_study_files[1], paste0(scale_of_study_files[1],".gz"))
R.utils::gzip(scale_of_study_files[2], paste0(scale_of_study_files[2],".gz"))
}
}
```

```{r interactions_to_interactors}
# interactions to proteins and genes
## tagging interactors by the scale of the study
{
all.IntAct.proteins_scale_l = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   large_scale = c(large_scale, large_scale))]
all.IntAct.proteins_scale_l = unique(all.IntAct.proteins_scale_l)
all.IntAct.proteins_scale = tidyr::spread(all.IntAct.proteins_scale_l, key = large_scale, value = large_scale, fill = "")
all.IntAct.proteins_scale = all.IntAct.proteins_scale[!(small_scale ==0 & large_scale ==0), ]
all.IntAct.proteins_scale[,large_small_scale := paste0(large_scale," | ",small_scale)]
all.IntAct.proteins_scale = unique(all.IntAct.proteins_scale)
}
# Calculating aggregated MI score per GeneID (includes interactions between proteins encoded by that gene)
{
  all.IntAct.proteins.score = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   Confidence_values = as.numeric(c(Confidence_values,Confidence_values)),
                   interactor_GeneID = c(IDs_interactor_A_GeneID, IDs_interactor_B_GeneID))]
  all.IntAct.proteins.score = unique(all.IntAct.proteins.score)
  all.IntAct.proteins.score[,Median_MI_score := median(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,Mean_MI_score := mean(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,sum_MI_score := sum(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,Confidence_values := NULL]
  all.IntAct.proteins.score = unique(all.IntAct.proteins.score)
}
# merging the number of interactions, the scale of the study, and the MIscore tables
{
all.IntAct.proteins = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   interactor_total_PMID = c(interactor_A_total_PMID,interactor_B_total_PMID),
                   Taxid_interactor = c(Taxid_interactor_A,Taxid_interactor_B),
                   interactor_IDs_databases = c(interactor_IDs_databases_A, interactor_IDs_databases_B),
                   unique_interactions_per_interactor = c(unique_interactions_per_interactor_A, unique_interactions_per_interactor_B),
                   N_interaction_IDs_per_interactor = c(N_interaction_IDs_per_interactor_A, N_interaction_IDs_per_interactor_B)
                   )]
all.IntAct.proteins = unique(all.IntAct.proteins)
all.IntAct.proteins[,unique_interactions_per_interactor := sum(unique_interactions_per_interactor), by = IDs_interactor]
all.IntAct.proteins[,N_interaction_IDs_per_interactor := sum(N_interaction_IDs_per_interactor), by = IDs_interactor]
all.IntAct.proteins = unique(all.IntAct.proteins)
all.IntAct.proteins = merge(all.IntAct.proteins,all.IntAct.proteins_scale, by.x = "IDs_interactor", by.y = "IDs_interactor",all = T)
all.IntAct.proteins= unique(all.IntAct.proteins)
all.IntAct.proteins = merge(all.IntAct.proteins,all.IntAct.proteins.score, by.x = "IDs_interactor", by.y = "IDs_interactor",all = T)
all.IntAct.proteins= unique(all.IntAct.proteins)
}


```

```{r select_species_and_uniprot}
{
# Select only relevant species, only uniprotkb identifiers,
  all.IntAct.proteins = all.IntAct.proteins[Taxid_interactor %in% SPECIES_IDs & interactor_IDs_databases == "uniprotkb",]
  
  # filter out proteins not mapped to geneID
  all.IntAct.proteins = all.IntAct.proteins[,n_geneid := as.numeric(length(unique(interactor_GeneID))),by = IDs_interactor]
  # filter out interactors without gene ids mapped to them
  all.IntAct.proteins.with.geneID = copy(all.IntAct.proteins[,n_protid := as.numeric(length(unique(IDs_interactor))),by = interactor_GeneID][n_protid < max(n_protid),])
  # tag proteins by the number of mappings - one_to_one or one_to_many
  all.IntAct.proteins.with.geneID[n_geneid > 1 | n_protid > 1, gene_id_prot_id := "one_to_many"]
  # filter out genes without proteins mapped to them - NA
  all.IntAct.proteins.with.geneID[n_geneid == 1 & n_protid == 1, gene_id_prot_id := "one_to_one"]

  SPECIES_NAME_ID = data.table(SPECIES_ID = SPECIES_IDs, SPECIES_NAME = SPECIES_NAME)
  all.IntAct.proteins.with.geneID = merge(all.IntAct.proteins.with.geneID, SPECIES_NAME_ID, by.x = "Taxid_interactor", by.y = "SPECIES_ID", all=FALSE)
  # filter out proteins without publications and proteins without MI score
  all.IntAct.proteins.with.geneID = all.IntAct.proteins.with.geneID[complete.cases(all.IntAct.proteins.with.geneID),]
  # filter out "one_to_many" and delete unnecessary columns
  all.IntAct.proteins.with.geneID = all.IntAct.proteins.with.geneID[gene_id_prot_id == "one_to_one",]
  all.IntAct.proteins.with.geneID[,c("Taxid_interactor","interactor_IDs_databases","interactor_GeneID","Mean_MI_score","n_geneid",'n_protid',"gene_id_prot_id") := NULL]
  all.IntAct.proteins.with.geneID = unique(all.IntAct.proteins.with.geneID)
}
```


   Just to be clear: for each protein which has all interacting partners identified exclusively by large-scale studies, or small-scale studies, or both large-scale and small-scale studies we show the number of interacting partners (which were indentified in those three types of studies) and the number of publications, any type of study involving the gene which codes for that particular protein. 
   To emphasise, in the figures below, we do not examine whether the same protein has a different number of interacting partners coming from large-scale or small-scale studies, we aggregate all those proteins into one group and count the total number of interacting partners each protein has (each particular interaction may have been identified in many large-scale studies, or many small-scale studies, or both large-scale and small-scale studies).
   
   The figures below show the number of interacting partners associated with the number of publications (x-axis) for different species and the scale of the experiment (split into individual graphs). The trendline was fitted to the data using robust linear regression (blue line) which less sensitive to outliers than linear regression (red line) and is, therefore, able to better capture the relationships. Both axes are log-transformed (which means linear trendline will stay linear if remove log transformation - log-transformed scale only allows to visualise individual points better).
   
```{r N_publications_vs_N_interactions_2groups, fig.height=9, fig.width=9, fig.cap= "Figure 8"}
# plotting unique_interactions_per_interactor as a function of the number of publications 
{
all.IntAct.proteins.with.geneID2 = copy(all.IntAct.proteins.with.geneID)
temp1 = copy(all.IntAct.proteins.with.geneID2)
temp2 = copy(all.IntAct.proteins.with.geneID2)
temp1[large_scale == "large_scale", scale_of_study := "large_scale"]
temp2[small_scale == "small_scale", scale_of_study := "small_scale"]
temp1 = temp1[scale_of_study == "large_scale",]
temp2 = temp2[scale_of_study == "small_scale",]
all.IntAct.proteins.with.geneID2 = unique(rbind(temp1,temp2))

rm(list = c("temp1", "temp2"))

ggplot(all.IntAct.proteins.with.geneID2, aes(interactor_total_PMID, unique_interactions_per_interactor)) +  scale_x_log10() + scale_y_log10() +
    ggtitle("The relationship between the number of publications per gene and \n the number of interacting partners of proteins encoded by that gene", subtitle = "blue line was fitted using robust linear regression, \n all UniprotAC were coerced to generic UniprotAC, \n large and small scale experiments")+
    ylab("the number of interacting partners (per protein)") + xlab("the number of publications (per gene)") + geom_smooth(method = "rlm", se = T) +
  facet_grid(SPECIES_NAME~scale_of_study, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1) +
    theme(strip.text.y = element_text(angle = 0)) + geom_smooth(method = "lm", se = T, aes(color = "red"))
}
```
   
   Now, we can separate proteins whose interacting partners were indentified in both large and small scale studies into separate group and see how that can change the trend.

```{r N_publications_vs_N_interactions_3groups2, fig.height=9, fig.width=9, fig.cap= "Figure 8"}
# plotting unique_interactions_per_interactor as a function of the number of publications 
{
ggplot(all.IntAct.proteins.with.geneID, aes(interactor_total_PMID, unique_interactions_per_interactor)) +  scale_x_log10() + scale_y_log10() +
    ggtitle("The relationship between the number of publications per gene and \n the number of interacting partners of proteins encoded by that gene", subtitle = "blue line was fitted using robust linear regression, \n all UniprotAC were coerced to generic UniprotAC, \n large and small scale experiments")+
    ylab("the number of interacting partners (per protein)") + xlab("the number of publications (per gene)") + geom_smooth(method = "rlm", se = T) +
  facet_grid(SPECIES_NAME~large_small_scale, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1) +
    theme(strip.text.y = element_text(angle = 0)) + geom_smooth(method = "lm", se = T, aes(color = "red"))
}
```

   Evidently, the difference in trend observed is only subtle, suggesting large scale studies (more than 100 interactions) are still biased towards more studied proteins.
   
   We can increase the thresold we use to define large scale study from 100 interactions per study to 1000 interactions per study to see how that influences the trend.
   
```{r large_scal_small_scale_threshold_500}
# tag interactions by the scale of the study
{
# tagging interactons
all.IntAct.modif[,large_scale := ifelse(interaction_ids_per_Publication > 1000, "large_scale", "small_scale")]
}
#interactions_to_interactors
# interactions to proteins and genes
## tagging interactors by the scale of the study
{
all.IntAct.proteins_scale_l = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   large_scale = c(large_scale, large_scale))]
all.IntAct.proteins_scale_l = unique(all.IntAct.proteins_scale_l)
all.IntAct.proteins_scale = tidyr::spread(all.IntAct.proteins_scale_l, key = large_scale, value = large_scale, fill = "")
all.IntAct.proteins_scale = all.IntAct.proteins_scale[!(small_scale ==0 & large_scale ==0), ]
all.IntAct.proteins_scale[,large_small_scale := paste0(large_scale," | ",small_scale)]
all.IntAct.proteins_scale = unique(all.IntAct.proteins_scale)
}
# Calculating aggregated MI score per GeneID (includes interactions between proteins encoded by that gene)
{
  all.IntAct.proteins.score = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   Confidence_values = as.numeric(c(Confidence_values,Confidence_values)),
                   interactor_GeneID = c(IDs_interactor_A_GeneID, IDs_interactor_B_GeneID))]
  all.IntAct.proteins.score = unique(all.IntAct.proteins.score)
  all.IntAct.proteins.score[,Median_MI_score := median(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,Mean_MI_score := mean(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,sum_MI_score := sum(Confidence_values, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,Confidence_values := NULL]
  all.IntAct.proteins.score = unique(all.IntAct.proteins.score)
}
# merging the number of interactions, the scale of the study, and the MIscore tables
{
all.IntAct.proteins_500 = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   interactor_total_PMID = c(interactor_A_total_PMID,interactor_B_total_PMID),
                   Taxid_interactor = c(Taxid_interactor_A,Taxid_interactor_B),
                   interactor_IDs_databases = c(interactor_IDs_databases_A, interactor_IDs_databases_B),
                   unique_interactions_per_interactor = c(unique_interactions_per_interactor_A, unique_interactions_per_interactor_B),
                   N_interaction_IDs_per_interactor = c(N_interaction_IDs_per_interactor_A, N_interaction_IDs_per_interactor_B)
                   )]
all.IntAct.proteins_500 = unique(all.IntAct.proteins_500)
all.IntAct.proteins_500[,unique_interactions_per_interactor := sum(unique_interactions_per_interactor), by = IDs_interactor]
all.IntAct.proteins_500[,N_interaction_IDs_per_interactor := sum(N_interaction_IDs_per_interactor), by = IDs_interactor]
all.IntAct.proteins_500 = unique(all.IntAct.proteins_500)
all.IntAct.proteins_500 = merge(all.IntAct.proteins_500,all.IntAct.proteins_scale, by.x = "IDs_interactor", by.y = "IDs_interactor",all = T)
all.IntAct.proteins_500= unique(all.IntAct.proteins_500)
all.IntAct.proteins_500 = merge(all.IntAct.proteins_500,all.IntAct.proteins.score, by.x = "IDs_interactor", by.y = "IDs_interactor",all = T)
all.IntAct.proteins_500= unique(all.IntAct.proteins_500)
}
# select_species_and_uniprot}
{
# Select only relevant species, only uniprotkb identifiers,
  all.IntAct.proteins_500 = all.IntAct.proteins_500[Taxid_interactor %in% SPECIES_IDs & interactor_IDs_databases == "uniprotkb",]
  
  # filter out proteins not mapped to geneID
  all.IntAct.proteins_500[,n_geneid := as.numeric(length(unique(interactor_GeneID))),by = IDs_interactor]
  # filter out interactors without gene ids mapped to them
  all.IntAct.proteins.with.geneID_500 = copy(all.IntAct.proteins_500[,n_protid := as.numeric(length(unique(IDs_interactor))),by = interactor_GeneID][n_protid < max(n_protid),])
  # tag proteins by the number of mappings - one_to_one or one_to_many
  all.IntAct.proteins.with.geneID_500[n_geneid > 1 | n_protid > 1, gene_id_prot_id := "one_to_many"]
  # filter out genes without proteins mapped to them - NA
  all.IntAct.proteins.with.geneID_500[n_geneid == 1 & n_protid == 1, gene_id_prot_id := "one_to_one"]

  SPECIES_NAME_ID = data.table(SPECIES_ID = SPECIES_IDs, SPECIES_NAME = SPECIES_NAME)
  all.IntAct.proteins.with.geneID_500 = merge(all.IntAct.proteins.with.geneID_500, SPECIES_NAME_ID, by.x = "Taxid_interactor", by.y = "SPECIES_ID", all=FALSE)
  # filter out proteins without publications and proteins without MI score
  all.IntAct.proteins.with.geneID_500 = all.IntAct.proteins.with.geneID_500[complete.cases(all.IntAct.proteins.with.geneID_500),]
  # filter out "one_to_many" and delete unnecessary columns
  all.IntAct.proteins.with.geneID_500 = all.IntAct.proteins.with.geneID_500[gene_id_prot_id == "one_to_one",]
  all.IntAct.proteins.with.geneID_500[,c("Taxid_interactor","interactor_IDs_databases","interactor_GeneID","Mean_MI_score","n_geneid",'n_protid',"gene_id_prot_id") := NULL]
  all.IntAct.proteins.with.geneID_500 = unique(all.IntAct.proteins.with.geneID_500)
}
```

```{r N_publications_vs_N_interactions_3groups3, fig.height=9, fig.width=9, fig.cap= "Figure 8"}
# plotting unique_interactions_per_interactor as a function of the number of publications 
{
ggplot(all.IntAct.proteins.with.geneID_500, aes(interactor_total_PMID, unique_interactions_per_interactor)) +  scale_x_log10() + scale_y_log10() +
    ggtitle("The relationship between the number of publications per gene and \n the number of interacting partners of proteins encoded by that gene", subtitle = "blue line was fitted using robust linear regression, \n all UniprotAC were coerced to generic UniprotAC, \n large and small scale experiments")+
    ylab("the number of interacting partners (per protein)") + xlab("the number of publications (per gene)") + geom_smooth(method = "rlm", se = T) +
  facet_grid(SPECIES_NAME~large_small_scale, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1) +
    theme(strip.text.y = element_text(angle = 0)) + geom_smooth(method = "lm", se = T, aes(color = "red"))
}
```

   Figure above suggests that studies which have identified more than 1000 interations (not covered by any of the small-scale studies) are less biased towards better researched proteins. Studies in yeast and *C.elegans* are notable exceptions: they still discover more interacting partners for better researched proteins. In contrast, human large-scale experiments tend identify more interacting partners for less researched proteins. This is not surprising since many of those studies aim to identify interacting partners for proteins with no known interacting partners.
   
   The fact that the study of any scale identifies more interactions for proteins which are well studied (even large-scale studies, 100 interaction/study threshold) may arise from the fact that if two studies search for interacting partners of the same protein they are going to find some interacting partners specific to a study. Therefore, as soon as we analyse overlapping studies (including large scale) we will have more interacting partners for better studied proteins. Therefore, any study which relies on combining multiple interaction datasets should use algorithms [] to account for study bias.
   
   
   Median MI score reflects how well studied are on average interactions between given protein and it's interacting partners.
   The figures below show the median MI score for interactions and how it relates to the number of publications (x-axis) for different species and the scale of the experiment (split into individual graphs). The trendline was fitted to the data using robust linear regression (blue line) which less sensitive to outliers than linear regression (red line) and is, therefore, able to better capture the relationships. Both axes are log-transformed (which means linear trendline will stay linear if remove log transformation - log-transformed scale only allows to visualise individual points better).

```{r publications_vs_MI_score, fig.height=9, fig.width=9, fig.cap= "Figure 9"}
library(MASS)
# plotting sum_MI_score as a function of the number of publications 
library(ggplot2)
{
ggplot(all.IntAct.proteins.with.geneID, aes(interactor_total_PMID, Median_MI_score))+ scale_x_log10() +
   #geom_density_2d(bins = 15,aes(colour=..level..)) + 
     #scale_color_gradient(low = "grey", high = "black")+
    ggtitle("The relationship between the number of publications per gene and the median MI score of interactions", subtitle = "blueline was fitted using robust linear regression, large and small scale experiments")+
    ylab("Median MI score for the interactions \n including the proteins encoded by that gene") + xlab("the number of publications (per gene)") +     geom_smooth(method = "rlm", se = T) +
  facet_grid(SPECIES_NAME~large_small_scale, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1)+
    theme(strip.text.y = element_text(angle = 0))+     geom_smooth(method = "lm", se = T, aes(color = "red"))
}

```


  You can clearly see that the more studied overall the gene is (the more publications per gene there is) the more interactions proteins encoded by that gene tend to have and the more evidence there is for those interactions. Which is not surprising because journals tend to publish novel interactions, and the more studies there is overall - the more studies look into protein interactions. What is quite surprising is that large scale experiments also exhibit this trend. The exception is human and mouse large scale studies, where recent datasets specifically attempted to find interactions for understudied proteins[].
  In this analysis, MI score for each interaction incorporates the evidence from any interaction detetection experiment and we are not able to separate the score for proteins studied in both large and small scale studies (which we do in the next chapter). 
  
  
### MI score based on either large- or small- scale experiments
  
  By taking recalculating MI score based on either large- or small- scale experiments (by separating the effects) we can get a better estimate the publication bias in those types of studies. We used the threshold of 100 to define large-scale study.

```{r MI_score_recalculated}
{
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
SPECIES_IDs = character()
source("SPECIES_NAME_TO_ID.R")
count = 1
for(species in SPECIES_NAME) {
  x = SPECIES_NAME_TO_ID(species)
  SPECIES_IDs[count] = x$SPECIES_ID
  count = count+1
  rm(list = "x")
}
}

{
  
large_scale_MI_score = fread("./Data/clustered_scored/large_scale_100_02_17_all_IntAct_cluster_local.txt", header = F, stringsAsFactors = F)
large_scale_MI_score[,scale_of_the_study_100 := "large_scale"]
large_scale_MI_score = large_scale_MI_score[,.(V14,V15,scale_of_the_study_100)]
small_scale_MI_score = fread("./Data/clustered_scored/small_scale_100_02_17_all_IntAct_cluster_local.txt", header = F, stringsAsFactors = F)
small_scale_MI_score[,scale_of_the_study_100 := "small_scale"]
small_scale_MI_score = small_scale_MI_score[,.(V14,V15,scale_of_the_study_100)]
scale_of_the_study_MIscore = rbind(large_scale_MI_score,small_scale_MI_score)

scale_of_the_study_MIscore[, Confidence_values_new := gsub("^intact-miscore:[[:digit:]]\\.[[:digit:]].*\\|miscore:","", V15)]
scale_of_the_study_MIscore[, V15 := NULL]
scale_of_the_study_MIscore[, Confidence_values_new := gsub("-","NA",Confidence_values_new)]
scale_of_the_study_MIscore[, Confidence_values_new := as.numeric(Confidence_values_new)]
inter_id = function(Interaction_identifiers,Confidence_values_new, scale_of_the_study_100) {
  ids = gsubfn::strapplyc(Interaction_identifiers,"EBI-[[:digit:]]+",simplify = T)
  data.table(Interaction_identifiers = ids, 
             Confidence_values_new = Confidence_values_new,
             scale_of_the_study_100 = scale_of_the_study_100)
}
inter_id = compiler::cmpfun(inter_id) # byte-compiling the function which is applied multiple times speeds up the computation (505.981 sec to 478.425 sec)
scale_of_the_study_MIscore = scale_of_the_study_MIscore[, inter_id(V14,Confidence_values_new, scale_of_the_study_100), by = V14]
scale_of_the_study_MIscore[, V14 := NULL]
setnames(scale_of_the_study_MIscore, colnames(scale_of_the_study_MIscore)[1], "Interaction_identifiers")
}
# checking no interactions have been lost
# sum(!unique(all.IntAct.modif$Interaction_identifiers) %in% unique(scale_of_the_study_MIscore$Interaction_identifiers))
# sum(!unique(scale_of_the_study_MIscore$Interaction_identifiers) %in% unique(all.IntAct.modif$Interaction_identifiers))
# sum(!unique(all.IntAct$Interaction_identifiers) %in% unique(scale_of_the_study_MIscore$Interaction_identifiers))
# sum(!unique(all.IntAct.modif$Interaction_identifiers) %in% unique(all.IntAct$Interaction_identifiers))

## combining recalculated MI scores with other interaction information 
all.IntAct.modif = merge(x = unique(all.IntAct.modif), y = unique(scale_of_the_study_MIscore),
                         by.x = "Interaction_identifiers", by.y = "Interaction_identifiers")

## Recalculating per protein information

#interactions_to_interactors
# interactions to proteins and genes

# Calculating aggregated MI score per GeneID (includes interactions between proteins encoded by that gene) and tagging interactors by the scale of the study (no need to get overlap group)
{
  all.IntAct.proteins.score = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   Confidence_values_new = as.numeric(c(Confidence_values_new,Confidence_values_new)),
                   interactor_GeneID = c(IDs_interactor_A_GeneID, IDs_interactor_B_GeneID),
                   scale_of_the_study_100 = c(scale_of_the_study_100, scale_of_the_study_100))]
  all.IntAct.proteins.score = unique(all.IntAct.proteins.score)
  all.IntAct.proteins.score[,Median_MI_score := median(Confidence_values_new, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,Mean_MI_score := mean(Confidence_values_new, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,sum_MI_score := sum(Confidence_values_new, na.rm = T), by = interactor_GeneID]
  all.IntAct.proteins.score[,Confidence_values_new := NULL]
  all.IntAct.proteins.score = unique(all.IntAct.proteins.score)
}
# calculating the number of interactions and merging to the MIscore table
{
all.IntAct.proteins_500 = all.IntAct.modif[,data.table(
                   IDs_interactor = c(IDs_interactor_A,IDs_interactor_B),
                   interactor_total_PMID = c(interactor_A_total_PMID,interactor_B_total_PMID),
                   Taxid_interactor = c(Taxid_interactor_A,Taxid_interactor_B),
                   interactor_IDs_databases = c(interactor_IDs_databases_A, interactor_IDs_databases_B),
                   unique_interactions_per_interactor = c(unique_interactions_per_interactor_A, unique_interactions_per_interactor_B),
                   N_interaction_IDs_per_interactor = c(N_interaction_IDs_per_interactor_A, N_interaction_IDs_per_interactor_B)
                   )]
all.IntAct.proteins_500 = unique(all.IntAct.proteins_500)
all.IntAct.proteins_500[,unique_interactions_per_interactor := sum(unique_interactions_per_interactor), by = IDs_interactor]
all.IntAct.proteins_500[,N_interaction_IDs_per_interactor := sum(N_interaction_IDs_per_interactor), by = IDs_interactor]
all.IntAct.proteins_500 = unique(all.IntAct.proteins_500)

all.IntAct.proteins_500 = merge(all.IntAct.proteins_500,all.IntAct.proteins.score, by.x = "IDs_interactor", by.y = "IDs_interactor",all = T)
all.IntAct.proteins_500= unique(all.IntAct.proteins_500)
}
# select_species_and_uniprot}
{
# Select only relevant species, only uniprotkb identifiers,
  all.IntAct.proteins_500 = all.IntAct.proteins_500[Taxid_interactor %in% SPECIES_IDs & interactor_IDs_databases == "uniprotkb",]
  
  # filter out proteins not mapped to geneID
  all.IntAct.proteins_500[,n_geneid := as.numeric(length(unique(interactor_GeneID))),by = IDs_interactor]
  # filter out interactors without gene ids mapped to them
  all.IntAct.proteins.with.geneID_500 = copy(all.IntAct.proteins_500[,n_protid := as.numeric(length(unique(IDs_interactor))),by = interactor_GeneID][n_protid < max(n_protid),])
  # tag proteins by the number of mappings - one_to_one or one_to_many
  all.IntAct.proteins.with.geneID_500[n_geneid > 1 | n_protid > 1, gene_id_prot_id := "one_to_many"]
  # filter out genes without proteins mapped to them - NA
  all.IntAct.proteins.with.geneID_500[n_geneid == 1 & n_protid == 1, gene_id_prot_id := "one_to_one"]

  SPECIES_NAME_ID = data.table(SPECIES_ID = SPECIES_IDs, SPECIES_NAME = SPECIES_NAME)
  all.IntAct.proteins.with.geneID_500 = merge(all.IntAct.proteins.with.geneID_500, SPECIES_NAME_ID, by.x = "Taxid_interactor", by.y = "SPECIES_ID", all=FALSE)
  # filter out proteins without publications and proteins without MI score
  all.IntAct.proteins.with.geneID_500 = all.IntAct.proteins.with.geneID_500[complete.cases(all.IntAct.proteins.with.geneID_500),]
  # filter out "one_to_many" and delete unnecessary columns
  all.IntAct.proteins.with.geneID_500 = all.IntAct.proteins.with.geneID_500[gene_id_prot_id == "one_to_one",]
  all.IntAct.proteins.with.geneID_500[,c("Taxid_interactor","interactor_IDs_databases","interactor_GeneID","Mean_MI_score","n_geneid",'n_protid',"gene_id_prot_id") := NULL]
  all.IntAct.proteins.with.geneID_500 = unique(all.IntAct.proteins.with.geneID_500)
}
``` 

```{r N_publications_vs_recalculated_MI_score_median, fig.height=9, fig.width=9, fig.cap= "Figure 8"}
{
ggplot(all.IntAct.proteins.with.geneID_500, aes(interactor_total_PMID, Median_MI_score))+ scale_x_log10() +
   #geom_density_2d(bins = 15,aes(colour=..level..)) + 
     #scale_color_gradient(low = "grey", high = "black")+
    ggtitle("The relationship between the number of publications per gene and the median MI score of interactions", subtitle = "blueline was fitted using robust linear regression, large and small scale experiments")+
    ylab("Median MI score for the interactions \n including the proteins encoded by that gene") + xlab("the number of publications (per gene)") +     geom_smooth(method = "rlm", se = T) +
  facet_grid(SPECIES_NAME~scale_of_the_study_100, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1)+
    theme(strip.text.y = element_text(angle = 0))+     geom_smooth(method = "lm", se = T, aes(color = "red"))
}
```

```{r N_publications_vs_recalculated_MI_score_sum, fig.height=9, fig.width=9, fig.cap= "Figure 8"}
{
ggplot(all.IntAct.proteins.with.geneID_500, aes(interactor_total_PMID, sum_MI_score))+ scale_x_log10() +
   #geom_density_2d(bins = 15,aes(colour=..level..)) + 
     #scale_color_gradient(low = "grey", high = "black")+
    ggtitle("The relationship between the number of publications per gene and the sum of MI score of the interactions", subtitle = "blueline was fitted using robust linear regression, large and small scale experiments")+
    ylab("Sum MI score of the interactions \n including the proteins encoded by that gene") + xlab("the number of publications (per gene)") +     geom_smooth(method = "rlm", se = T) +
  facet_grid(SPECIES_NAME~scale_of_the_study_100, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1)+
    theme(strip.text.y = element_text(angle = 0))+     geom_smooth(method = "lm", se = T, aes(color = "red"))
}
```

### The number of interactions and publication separated by interaction detection method
  

```{r interaction_properties_vs_pubN, fig.height=9, fig.width=10, fig.cap= "Figure 10"}
       # read the saved table with human_not_in_IMEx_protein_properties_processing chunk
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis
reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
proteome_vs_imex_interaction_details_all = data.table()
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_interaction_details_f = as.data.table(read.delim(filename, header = T, stringsAsFactors = F,quote=""))
n = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", n)
n = gsub("strain K12", "Escherichia coli, strain K12", n)
proteome_vs_imex_interaction_details_f[ , c("SPECIES_NAME","reviewed","isoforms", "SPECIES_ID") := list(n,r,i,SPECIES_ID)]
proteome_vs_imex_interaction_details_all = rbind(proteome_vs_imex_interaction_details_all,proteome_vs_imex_interaction_details_f, fill =T)
    }}}
all.IntAct.protein_interaction_details_all = merge(x = proteome_vs_imex_interaction_details_all, y=all.IntAct.proteins.with.geneID, by.x = "whole_proteome_IDs", by.y = "IDs_interactor", all.x=T, all.y = F)

all.IntAct.protein_interaction_details_all = all.IntAct.protein_interaction_details_all[two_hybrid_vs_AP_MS != "not in IMEx" & SPECIES_NAME.x %in% c("Homo sapiens", "Mus musculus", "S. cerevisiae, strain S288c", "Escherichia coli, strain K12") & !is.na(large_small_scale),]
all.IntAct.protein_interaction_details_all = unique(all.IntAct.protein_interaction_details_all)
{
ggplot(all.IntAct.protein_interaction_details_all, aes(interactor_total_PMID, unique_interactions_per_interactor, color = two_hybrid_vs_AP_MS))+
    scale_x_log10()+ scale_y_log10()  + 
    ggtitle("The relationship between the number of publications per gene and \n the number of interactions in which proteins encoded by that gene participate", subtitle = "line was fitted using robust linear regression, \n all UniprotAC were coerced to generic UniprotAC, \n grouped by interaction detection method (colour), \n large and small scale experiments")+
    ylab("the number of interactions(per protein) in which proteins encoded by that gene participate") + xlab("the number of publications per gene") +
     geom_smooth(method = "rlm", se = T)+
  facet_grid(SPECIES_NAME.x~large_small_scale, scales = "free_y") + geom_point(size = 0.5, alpha = 0.1)+
    theme(strip.text.y = element_text(angle = 0))
}
```


You can notice that trendlines for different methods are located at different heights, which tells us that different methods identify a different number of interactions across both large and small scale studies. Some trends are not meaningful due to a low number of proteins contained in the group they describe. 

The plot below shows how the distribution of the number of interacting partners depends on the protein detection method. Spoke expanded interactions are included.


```{r interaction_properties_vs_unique_interactors, fig.height=8, fig.width=10}
       # read the saved table with human_not_in_IMEx_protein_properties_processing chunk

# spoke-expanded included
library(ggplot2)
library(scales)
ggplot(all.IntAct.protein_interaction_details_all, aes(y=unique_interactions_per_interactor, x =two_hybrid_vs_AP_MS, fill = two_hybrid_vs_AP_MS))+ 
    ggtitle("the number of interacting partners associated with the protein detection method and the scale of the study", subtitle = "all UniprotAC were coerced to generic UniprotAC, \n grouped by interaction detection method (colour), \n large and small scale experiments")+
    ylab("the number of interacting partners") + xlab("interaction detection method") +
  facet_grid(SPECIES_NAME.x~large_small_scale, scales = "free") + geom_boxplot(alpha =0.7)+scale_y_log10()+
     theme(strip.text.y = element_text(angle = 0), axis.text.x = element_text(angle = -35,vjust = 0.65))
```


  The number of interaction IDs per protein relates to the number of experiments (not publications or interacting partners) in which interaction between given protein and it's interacting partners was detected.

```{r interaction_properties_vs_unique_interaction_IDs, fig.height=8, fig.width=10}
       # read the saved table with human_not_in_IMEx_protein_properties_processing chunk

# spoke-expanded included
library(ggplot2)
library(scales)
ggplot(all.IntAct.protein_interaction_details_all, aes(y=N_interaction_IDs_per_interactor, x =two_hybrid_vs_AP_MS, fill = two_hybrid_vs_AP_MS))+ 
    ggtitle("the number of interactions (interaction IDs) associated with the protein detection method and the scale of the study", subtitle = "all UniprotAC were coerced to generic UniprotAC, \n grouped by interaction detection method (colour), \n large and small scale experiments")+
    ylab("the number of interaction IDs, interaction detection experiments") + xlab("interaction detection method") +
  facet_grid(SPECIES_NAME.x~large_small_scale, scales = "free") + geom_boxplot(alpha =0.7)+scale_y_log10()+
     theme(strip.text.y = element_text(angle = 0), axis.text.x = element_text(angle = -35,vjust = 0.65))
```

   The number of interacting partners should be linearly dependent on the number of experiments they were detected in

```{r interaction_properties_vs_unique_interaction_IDs_vs_unique_interactors, fig.height=8, fig.width=10}
library(ggplot2)
library(scales)
ggplot(all.IntAct.protein_interaction_details_all, aes(y=unique_interactions_per_interactor , x =N_interaction_IDs_per_interactor, color = two_hybrid_vs_AP_MS))+ 
    ggtitle("the number of interactions (interaction IDs) associated with the number of times interaction was reported, the protein detection method and the scale of the study", subtitle = "all UniprotAC were coerced to generic UniprotAC, \n divided by interaction detection method (colour), \n large and small scale experiments")+
    ylab("the number of interacting partners") + xlab("interaction detection method") +
  facet_grid(SPECIES_NAME.x~large_small_scale, scales = "free") + geom_point(alpha =0.7)+scale_y_log10()+scale_x_log10()+geom_smooth(method = "rlm")+
     theme(strip.text.y = element_text(angle = 0), axis.text.x = element_text(angle = -35,vjust = 0.65))
```


Comparison of figures which relate the number of interacting partners to the interaction detection method and how well those proteins are studied suggests that proteins have the more interacting partners the more experimental attempts were done to identify them and if the proteins were studied using different interaction detection methods. This supports the idea that different interaction detection methods identify different interactions based on each method bias (as discussed in the chapter 5). 

## 7. Proteins with no interacting partners are less studied overall

```{r reading_and_merging_sql}
# Reading SQL database for information about the disordered proteins
library(RSQLite)
library(data.table)
# connect to the sqlite file
disorder = dbConnect(SQLite(), db = "./Data/Vincent_and_Schnell_2016_v2.db")
# get a list of all tables
alltables = dbListTables(disorder)
# get the everything from CD_counts table as a data.frame
Percent_disorder = dbGetQuery( disorder,'select * from Percent_disorder')
Percent_disorder = as.data.table(Percent_disorder)
# count the areas in the SQLite table
CIDER_data = dbGetQuery( disorder,'select * from CIDER_data')
CIDER_data = as.data.table(CIDER_data)
dbDisconnect(disorder)

SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508")
## only reviewed = 2 and isoforms = FALSE is relevant for this analysis - "strain K12" Ecoli is not characterised in disorder study

reviewed = 2
isoforms = FALSE
##============================================================================##
source("SPECIES_NAME_TO_ID.R")
proteome_vs_imex_interaction_details_all = data.table()
library(dplyr)
for (r in reviewed) {
  for (i in isoforms) {
    for (n in SPECIES_NAME) {
      SPECIES_IDs = SPECIES_NAME_TO_ID(n)
      SPECIES_ID = SPECIES_IDs$SPECIES_ID

filename = paste("./analysis/","proteome_vs_interactome_interaction_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
proteome_vs_imex_interaction_details_f = as.data.table(read.delim(filename, header = T, stringsAsFactors = F,quote=""))
n = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", n)
n = gsub("strain K12", "Escherichia coli, strain K12", n)
proteome_vs_imex_interaction_details_f[ , c("SPECIES_NAME","reviewed","isoforms", "SPECIES_ID") := list(n,r,i,SPECIES_ID)]
proteome_vs_imex_interaction_details_all = rbind(proteome_vs_imex_interaction_details_all,proteome_vs_imex_interaction_details_f, fill =T)
    }}}
all.IntAct.protein_interaction_details_all = merge(x = proteome_vs_imex_interaction_details_all, y=all.IntAct.proteins, by.x = "whole_proteome_IDs", by.y = "IDs_interactor", all.x = T, all.y = F)

proteome_vs_imex_interaction_details_f_Percent_disorder.t = merge(x = all.IntAct.protein_interaction_details_all,
                                                       y = Percent_disorder,
                                                       by.x = "whole_proteome_IDs",
                                                       by.y = "UniProtKB_AC",
                                                       all.x = T,
                                                       all.y = F)
proteome_vs_imex_interaction_details_f_Percent_disorder = merge(x = proteome_vs_imex_interaction_details_f_Percent_disorder.t,
                                                       y = CIDER_data,
                                                       by.x = "whole_proteome_IDs",
                                                       by.y = "UniProtKB_AC",
                                                       all.x = T,
                                                       all.y = F)
proteome_vs_imex_interaction_details_f_Percent_disorder[is.na(proteome_vs_imex_interaction_details_f_Percent_disorder)] = 0

# re-map publication numbers: remap uniprotAC to geneID for proteins absent in IMEx and count publications
# reading files for uniprotAC to geneID mapping
uniprotAC2geneID = data.table()
for(i in 1:length(uniprotAC2geneID_filename.dat)){
  temp = fread(uniprotAC2geneID_filename.dat[i], header = F)
  temp = temp[V2 == "GeneID", .(V1, V3)]
  uniprotAC2geneID = rbind(uniprotAC2geneID,temp)
  rm(list = "temp")
}
## map GeneIDs for IDs_interactor_A
{
colnames(uniprotAC2geneID)[2] = "whole_proteome_IDs2GeneID"
proteome_vs_imex_interaction_details_f_Percent_disorder = merge(x=proteome_vs_imex_interaction_details_f_Percent_disorder, y=uniprotAC2geneID, by.x = "whole_proteome_IDs", by.y = "V1", all.x=TRUE, all.y = F)
}
rm(list = "uniprotAC2geneID")

## count the number of pubmed PMID per GeneIDs for IDs_interactor_A and B
{
geneID2pubmed_url = "ftp://ftp.ncbi.nih.gov/gene/DATA/gene2pubmed.gz"
geneID2pubmed_filename = paste0("./Data/geneID2pubmed_release_", format(Sys.Date(), "%m-%Y.gz"))
geneID2pubmed_filename_txt = substr(geneID2pubmed_filename, 1, nchar(geneID2pubmed_filename)-3)
geneID2pubmed = fread(geneID2pubmed_filename_txt, colClasses = c("character","character","character"))
geneID2pubmed = geneID2pubmed[,.(GeneID, PubMed_ID)]
# counting publications per GeneID
geneID2pubmed[, whole_proteome_IDs_PMID := length(PubMed_ID), by = GeneID]
# selecting only relevant columns
geneID2pubmed = geneID2pubmed[,unique(data.table(GeneID,whole_proteome_IDs_PMID))][,GeneID := as.character(GeneID)]
# merging N of PMID to all other data
proteome_vs_imex_interaction_details_f_Percent_disorder = merge(proteome_vs_imex_interaction_details_f_Percent_disorder, geneID2pubmed, by.x = "whole_proteome_IDs2GeneID", by.y = "GeneID", all.x=TRUE)
rm(list = "geneID2pubmed")
}
# delete GeneID column to remove many-GeneID-to-one-protein
proteome_vs_imex_interaction_details_f_Percent_disorder[,whole_proteome_IDs2GeneID := NULL]
proteome_vs_imex_interaction_details_f_Percent_disorder = unique(proteome_vs_imex_interaction_details_f_Percent_disorder)
# sum up publications for many-GeneID-to-one-protein cases 
proteome_vs_imex_interaction_details_f_Percent_disorder[,whole_proteome_IDs_PMID := sum(whole_proteome_IDs_PMID), by = whole_proteome_IDs]
# return to one unique protein per row representation
proteome_vs_imex_interaction_details_f_Percent_disorder = unique(proteome_vs_imex_interaction_details_f_Percent_disorder)
```


   Proteins without interacting partners annotated in IMEx are less studied overall both in yeast, human and mouse (species with different available interactome coverage). In fact, many of these proteins lack evidence at the protein or transcript level (as shown in Uniprot).


```{r presence_in_IMEx_vs_publications, fig.height=8, fig.width=8}
proteome_vs_imex_interaction_details_f_Percent_disorder[, whole_proteome_Uniprot_IMEx_x_SPECIES_NAME := paste0(whole_proteome_Uniprot_IMEx,SPECIES_NAME)]
proteome_vs_imex_interaction_details_f_Percent_disorder[, median_studies_per_group := median(log10(whole_proteome_IDs_PMID), na.rm = T), by = whole_proteome_Uniprot_IMEx_x_SPECIES_NAME]

ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder, aes(x = whole_proteome_IDs_PMID, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_freqpoly()+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("the number of studies , log10 scale")+ ggtitle("the distribution of the number of studies for proteins with \n and without interacting partners curated in IMEx") +geom_vline(aes(xintercept = 10^median_studies_per_group, color = whole_proteome_Uniprot_IMEx),alpha =0.7)

# for poster
proteome_vs_imex_interaction_details_f_Percent_disorder[, in_IMEx := ifelse(whole_proteome_Uniprot_IMEx == "SwissProt_and_IMEX", "yes", "no")]
protein_publ = ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder[SPECIES_NAME == "Homo sapiens",], aes(x = whole_proteome_IDs_PMID, color = in_IMEx, label = SPECIES_NAME)) +geom_freqpoly()+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("the number of publications (PMIDs), log10 scale")+ ggtitle("Number of publications for proteins with \n and without interacting partners curated in IMEx") +geom_vline(aes(xintercept = 10^median_studies_per_group, color = in_IMEx),alpha =0.7, size = 1.5)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```


## 8. Are proteins with a higher fraction of intrinsically disordered domains more likely to have interactions available?

### interaction information is not available for proteins with similar fraction of intrinsically disordered domains

   Is not exactly clear - more research in needed. The dataset generated by Vincent and Schnell has weird consensus disordered domain prediction (combining many prediction algorithms) while individual disordered domain prediction algorithms show contradicting results. For better quality disordered domain prediction we can use MobiDB (http://mobidb.bio.unipd.it), however, it's API is not very usable for proteome-wide study (it only allows to query protein by protein (other options are not very useful) and no more that 1 request/sec).
   Plots below show the distribution and the distribution density of the fraction of disordered regions (split by prediction algorithm) in a protein and the presence of that protein in IMEx databases.
   
```{r physical_properties_plot_disord_dom, fig.height=10, fig.width=12}
z = numeric(length(SPECIES_NAME))
for(i in 1:length(SPECIES_NAME)){
sp = proteome_vs_imex_interaction_details_f_Percent_disorder[SPECIES_NAME == SPECIES_NAME[i],]
z[i] =wilcox.test(Hydropathy_m~whole_proteome_Uniprot_IMEx, data = sp)$p.value
}
Percent_disorder_types_for_plot = melt(data = proteome_vs_imex_interaction_details_f_Percent_disorder,variable.name ="disorder_pred_algorithm",value.name ="percent_disorder",measure.vars =c("IUPRED_PD","COILS_PD","HOTLOOPS_PD","REM465_PD","ICHR_consensus_PD"))

Percent_disorder_types_for_plot[, whole_proteome_Uniprot_IMEx_x_disorder_pred_algorithm_SPECIES_NAME := paste0(whole_proteome_Uniprot_IMEx,disorder_pred_algorithm,SPECIES_NAME)]
Percent_disorder_types_for_plot[, median_percent_disorder:= median(log10(percent_disorder), na.rm = T), by = whole_proteome_Uniprot_IMEx_x_disorder_pred_algorithm_SPECIES_NAME]

ggplot(Percent_disorder_types_for_plot, aes(x = percent_disorder, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_freqpoly(bins = 100)+  facet_grid(SPECIES_NAME~disorder_pred_algorithm) + theme(strip.text.y = element_text(angle = 0)) +xlab("fraction of disordered regions, 0...100, log10 scale") + ggtitle("the distribution of the fraction of disordered regions for proteins with \n and without interacting partners annotated in IMEx")+scale_x_log10() +geom_vline(aes(xintercept = 10^median_percent_disorder, color = whole_proteome_Uniprot_IMEx),alpha =0.7)

ggplot(Percent_disorder_types_for_plot, aes(x = percent_disorder, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_density()+  facet_grid(SPECIES_NAME~disorder_pred_algorithm) + theme(strip.text.y = element_text(angle = 0)) +xlab("fraction of disordered regions, 0...100, log10 scale") + ggtitle("the distribution density of the fraction of disordered regions for proteins with \n and without interacting partners annotated in IMEx")+scale_x_log10() +geom_vline(aes(xintercept = 10^median_percent_disorder, color = whole_proteome_Uniprot_IMEx),alpha =0.7)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```


### proteins with interaction information available tend to have higher fraction of charged residues and lower mean hydropathy


The fraction of charged residues and the mean hydropathy are the physical properties of the protein which can influence protein's solubility and disorderliness.


```{r physical_properties_plot_FCR, fig.height=5, fig.width=8}
z = numeric(length(SPECIES_NAME))
for(i in 1:length(SPECIES_NAME)){
sp = proteome_vs_imex_interaction_details_f_Percent_disorder[SPECIES_NAME == SPECIES_NAME[i],]
z[i] =wilcox.test(Hydropathy_m~whole_proteome_Uniprot_IMEx, data = sp)$p.value
}

proteome_vs_imex_interaction_details_f_Percent_disorder[, median_FCR := median(log10(FCR), na.rm = T), by = whole_proteome_Uniprot_IMEx_x_SPECIES_NAME]

ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder, aes(x = FCR, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_freqpoly(bins = 100)+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("fraction of charged residues, 0...1, log10 scale") + ggtitle("the distribution of the fraction of charged residues for proteins with \n and without interacting curated annotated in IMEx") +geom_vline(aes(xintercept = 10^median_FCR, color = whole_proteome_Uniprot_IMEx),alpha =0.7)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))

ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder, aes(x = FCR, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_density()+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("fraction of charged residues, 0...1, log10 scale") + ggtitle("the distribution density of the fraction of charged residues for proteins with \n and without interacting curated annotated in IMEx") +geom_vline(aes(xintercept = 10^median_FCR, color = whole_proteome_Uniprot_IMEx),alpha =0.7)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))

# for poster
protein_charge = ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder[SPECIES_NAME == "Homo sapiens",], aes(x = FCR, color = in_IMEx, label = SPECIES_NAME)) +geom_freqpoly(bins = 100)+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("fraction of charged residues, 0...1, log10 scale") + ggtitle("Fraction of charged residues in proteins with \n and without interacting partners curated in IMEx") +geom_vline(aes(xintercept = 10^median_FCR, color = in_IMEx),alpha =0.7, size =1.5)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```

P-values for the differences: `r z[1]`, `r z[2]`, `r z[3]`.

```{r physical_properties_plot_Hydropathy_m, fig.height=5, fig.width=8}
z = numeric(length(SPECIES_NAME))
for(i in 1:length(SPECIES_NAME)){
sp = proteome_vs_imex_interaction_details_f_Percent_disorder[SPECIES_NAME == SPECIES_NAME[i],]
z[i] =wilcox.test(Hydropathy_m~whole_proteome_Uniprot_IMEx, data = sp)$p.value
}

proteome_vs_imex_interaction_details_f_Percent_disorder[, median_Hydropathy_m := median(log10(Hydropathy_m), na.rm = T), by = whole_proteome_Uniprot_IMEx_x_SPECIES_NAME]

ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder, aes(x = Hydropathy_m, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_freqpoly(bins = 100)+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("the mean hydropathy, log10 scale") + ggtitle("the distribution of the mean hydropathy for proteins with \n and without interacting partners curated in IMEx") +geom_vline(aes(xintercept = 10^median_Hydropathy_m, color = whole_proteome_Uniprot_IMEx),alpha =0.7)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))

ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder, aes(x = Hydropathy_m, color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_density()+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("the mean hydropathy, log10 scale") + ggtitle("the distribution of the mean hydropathy for proteins with \n and without interacting partners curated in IMEx") +geom_vline(aes(xintercept = 10^median_Hydropathy_m, color = whole_proteome_Uniprot_IMEx),alpha =0.7)+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))

#for poster
protein_hydropathy = ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder[SPECIES_NAME == "Homo sapiens",], aes(x = Hydropathy_m, color = in_IMEx, label = SPECIES_NAME)) +geom_freqpoly(bins = 100)+ scale_x_log10() + facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("the mean hydropathy, log10 scale") + ggtitle("Mean hydropathy in proteins with and without \n interacting partners curated in IMEx") +geom_vline(aes(xintercept = 10^median_Hydropathy_m, color = in_IMEx),alpha =0.7,size =1.5) +
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```

P-values for the differences: `r z[1]`, `r z[2]`, `r z[3]`.

Proteins which don't have interaction evidence in IntAct tend to have a lower fraction of charged residues and higher mean hydropathy. This correlates well with the GO (cellular component) enrichment result: these proteins are largely membrane proteins (this was done in Cytoscape, not in R yet).


## 9. Do proteins with a higher fraction of intrinsically disordered domains have more interacting partners?

  Recent attempt to correct for the study bias (explored in the previous chapter) while accessing whether a particular group of proteins form higher (or lower) number of interactions by Cerrano group [PMCID:PMC4523822] showed that it's possible and important to do so. Performing this correction as described in Cerrano's paper can allow evaluating whether proteins with intrinsically disordered domains actually form more interactions.
  One previous study [PMID:18924110] has already pointed out that proteins with disordered domains are more likely to be detected in protein interaction screens in yeast. We test whether that's true across multiple species.
  
### The number of studies vs the fraction predicted disordered regions

  As an alternative to splitting proteins into the ones which have long disordered domains and which don't, we can look at the continuous fraction of disordered domains. This measure can be less influenced by study bias.

  The plot below shows the relationship between the fraction of disordered domains and the number of publications. 

  
```{r disord_domain_vs_publications, fig.height=5, fig.width=12}
ggplot(Percent_disorder_types_for_plot, aes(x = whole_proteome_IDs_PMID, y = percent_disorder, label = SPECIES_NAME)) +geom_point(size = 0.05)+ scale_x_log10() + facet_grid(SPECIES_NAME~disorder_pred_algorithm) + theme(strip.text.y = element_text(angle = 0)) +ylab("fraction of disordered regions, 0...100")+xlab("the number of studies, log10 scale")  + ggtitle("the number of studies vs the fraction of disordered regions") +geom_smooth(method = "rlm", color = "blue")+geom_smooth(method = "loess", color = "red")+
        theme(panel.grid.major =  element_line(color = 'grey', size = 0.2, linetype = 'solid'),
              panel.background = element_rect(fill = '#FFFFFF', colour = 'grey')) + 
        scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
```
  
  The second plot is a quantile-quantile plot which shows that the distribution of the fraction of disordered domains is far from normal. Square root or logarithmic transformations do not change that.
  
```{r disord_domain_vs_publications_qqplot, fig.height=5, fig.width=12}
ggplot(Percent_disorder_types_for_plot, aes( sample = percent_disorder,color = whole_proteome_Uniprot_IMEx, label = SPECIES_NAME)) +geom_qq()+ facet_grid(SPECIES_NAME~disorder_pred_algorithm) + theme(strip.text.y = element_text(angle = 0)) + ggtitle("QQ-plot: the fraction of disordered regions")

```

   From these graphs, we can conclude that the fraction of disordered domains can vary depend on the number of studies and disordered region prediction algorithm (which may reflect the bias of disordered region prediction algorithms.

### Proteins with a low fraction of disordered domains tend to have fewer interactions

   If disordered regions are often needed for molecular interactions we would expect that proteins with a higher fraction of disordered regions will tend to have more interacting partners (irrespective of the study bias).

```{r disord_domain_vs_n_interactions, fig.height=5, fig.width=12}
# Percent_disorder_types_for_plot has disorder prediction algorithms and the results in rows(melted form) - only for disorder graphs
ggplot(Percent_disorder_types_for_plot, aes(x = percent_disorder, y = unique_interactions_per_interactor,alpha =0.7, label = SPECIES_NAME)) +geom_point(bins = 100)+ scale_y_log10()+geom_smooth(method = "rlm", color = "blue")+geom_smooth(method = "loess", color = "red")+ facet_grid(SPECIES_NAME~disorder_pred_algorithm) + theme(strip.text.y = element_text(angle = 0)) +xlab("fraction of disordered regions, 0...100")+ylab("the number of interacting partners")  + ggtitle("the number of interacting partners as a function of the fraction of disordered regions  \n line fitted using rlm ")

cor(Percent_disorder_types_for_plot$percent_disorder,Percent_disorder_types_for_plot$unique_interactions_per_interactor)
```

   As you can see from the loess-fitted curve (red, loess stands for local polynomial regression), the proteins with a low fraction of disordered domains tend to have fewer interactions while further increasing the fraction of disordered regions doesn't change the trend. The more general trend is shown in blue - robust linear regression. 
   Whether these trends are the result of chance or study bias is yet to be tested.

### The longer yeast protein is the more interactions it has (doesn't hold true for mouse)

   In theory, the length of the protein can influence the number of interaction partners of the protein: the longer the protein the more functional and structural domains it has and the more molecular interactions that function will require.
   
```{r protein_mass_vs_n_interactions, fig.height=8, fig.width=8}
# proteome_vs_imex_interaction_details_f_Percent_disorder has disorder prediction algorithms and the results in columns (spread form) 
ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder, aes(x = Length, y = unique_interactions_per_interactor, label = SPECIES_NAME)) +geom_point(bins = 100)+scale_x_log10()+ scale_y_log10()+geom_smooth(method = "rlm")+ facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("protein length, N amino acid residues, log10 scale")+ylab("the number of interacting partners, log10 scale")  + ggtitle("the number of interacting partners as a function of the protein length \n line fitted using rlm")

``` 

   The analysis shows that the number of interacting partners correlates with the protein length in yeast, but not in human or mouse.
   
### The length of the disordered regions and the number of interactions
   
   The sum length of disordered regions per protein can be a better predictor of the number of interacting partners because it captures both the presence of disordered regions and the fact that longer proteins have more functional domains. 

```{r protein_mass*disord_domain_vs_n_interactions, fig.height=5, fig.width=12}
# Percent_disorder_types_for_plot has disorder prediction algorithms and the results in rows(melted form) - only for disorder graphs
Percent_disorder_types_for_plot[, length_disorder := percent_disorder*Length/100]

ggplot(Percent_disorder_types_for_plot, aes(x = length_disorder, y = unique_interactions_per_interactor, label = SPECIES_NAME)) +geom_point(alpha =0.7)+ scale_y_log10()+geom_smooth(method = "rlm", color = "blue")+geom_smooth(method = "loess", color = "red")+ scale_x_log10()+ facet_grid(SPECIES_NAME~disorder_pred_algorithm) + theme(strip.text.y = element_text(angle = 0)) + xlab("the length of disordered regions, N amino acid residues, log10 scale")+ ylab("the number of interacting partners, log10 scale")  + ggtitle("the number of interacting partners as a function of the length of disordered regions \n line fitted using rlm")
``` 


## 10. The number of protein domains (InterPro) and the number of interactions

```{r InterPro_domains}

get_interpro = function(){
# Downloading UniprotID to InterPro, gz-unzipping, splitting file into many small files
url_interpro = "ftp://ftp.ebi.ac.uk/pub/databases/interpro/protein2ipr.dat.gz"
filename_interpro = paste0("./Data/protein2ipr_release_", format(Sys.Date(), "%m-%Y.dat.gz"))
filename_interpro1 = substr(filename_interpro, 1, nchar(filename_interpro)-3)
filename_interpro2 = substr(filename_interpro, 1, nchar(filename_interpro)-7)
#
if(!(length(list.files(filename_interpro2)) > 0)) {
  # Downloading UniprotID to InterPro
  downloader::download(url_interpro, filename_interpro)
  # gz-unzipping UniprotID to InterPro
  system(paste("gunzip", filename_interpro))
  # splitting file into many 5-million-line files
  system(paste("mkdir", filename_interpro2))
  system(paste0("split -l 5000000 ", 
                filename_interpro1," ",
                filename_interpro2,"/"))
}
filename_interpro3 = list.files(filename_interpro2)
# returns the vector of paths to interpro files
return(paste0(filename_interpro2, "/",filename_interpro3))
}

proteins2domains = function(proteins, interpro_files){
  domains = data.table::data.table()
  for(file in interpro_files){
    interpro = data.table::fread(file = file, stringsAsFactors = F, header = F, sep = "\t")
    domains = rbind(domains, interpro[V1 %in% proteins,])
  }
  setnames(domains, names(domains), c("UniprotID", "InterProID", "Description", "DomainID", "start", "stop"))
  return(domains)
}

filename.int = paste("./analysis/","proteome_vs_imex_interaction_details_f_Percent_disorder.interpro", date,".txt", sep = "")
filename.dom = paste("./analysis/","proteome_vs_imex_interpro_domains", date,".txt", sep = "")

if(!(file.exists(filename.int) & file.exists(filename.dom))){
  
interpro_files = get_interpro()
proteins = proteome_vs_imex_interaction_details_f_Percent_disorder$whole_proteome_IDs
domains = proteins2domains(proteins, interpro_files)
domains = unique(domains)

domains[, domains_per_protein := .N, by = UniprotID]

proteome_vs_imex_interaction_details_f_Percent_disorder.interpro = merge(proteome_vs_imex_interaction_details_f_Percent_disorder, domains[,unique(data.table(UniprotID = UniprotID, domains_per_protein = domains_per_protein))], by.x = "whole_proteome_IDs", by.y = "UniprotID", all = T)

write.table(proteome_vs_imex_interaction_details_f_Percent_disorder.interpro, filename.int, col.names=T,row.names=F,sep="\t",quote=F)
write.table(domains, filename.dom, col.names=T,row.names=F,sep="\t",quote=F)
}

if(file.exists(filename.int) & file.exists(filename.dom)){
  proteome_vs_imex_interaction_details_f_Percent_disorder.interpro = fread(filename.int)
  domains = fread(filename.dom)
}


```


```{r N_domain_vs_n_publications, fig.height=8, fig.width=8}
# proteome_vs_imex_interaction_details_f_Percent_disorder has disorder prediction algorithms and the results in columns (spread form) 
ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder.interpro, aes(x = whole_proteome_IDs_PMID  , y = domains_per_protein, label = SPECIES_NAME)) +geom_point()+scale_x_log10()+ scale_y_log10()+geom_smooth(method = "rlm")+ facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +ylab("the number of protein domains, log10 scale")+xlab("the number of studies, log10 scale")  + ggtitle("the number of studies vs the number of protein domains \n line fitted using rlm, curve using loess")

``` 


```{r N_domain_vs_n_interactions, fig.height=8, fig.width=8}
# proteome_vs_imex_interaction_details_f_Percent_disorder has disorder prediction algorithms and the results in columns (spread form) 
ggplot(proteome_vs_imex_interaction_details_f_Percent_disorder.interpro, aes(x = domains_per_protein, y = unique_interactions_per_interactor, label = SPECIES_NAME)) +geom_point()+scale_x_log10()+ scale_y_log10()+geom_smooth(method = "rlm")+ facet_grid(SPECIES_NAME~.) + theme(strip.text.y = element_text(angle = 0)) +xlab("the number of protein domains, log10 scale")+ylab("the number of interacting partners, log10 scale")  + ggtitle("the number of protein domains vs the number of interacting partners \n line fitted using rlm, curve using loess")

``` 

coming soon

# Supplementary figures

Supplementary figure 1 

```{r Supplementary1_IMEx_vs_Uniprot_venndiagram_all_Uniprot, cache=F, fig.width=8, fig.height=8, fig.cap="Supplementary figure 1. The overlap between proteins with known interactions (interactome) and all proteins included in UniprotKB (proteome)"}
filename.summary.all = paste("./results/","proteome_vs_interactome_summary_",date,".txt", sep = "")
{
  if(file.exists(filename.summary.all)) proteome_vs_interactome_summary.all = fread(filename.summary.all, sep = "\t", stringsAsFactors = F, data.table = F)
}
## Plotting with venn.diagram - Uniprot vs IMEx (or IntAct)
# code to be modified for different graphs
SPECIES_NAME = c("Homo sapiens", "Mus musculus", "strain ATCC 204508", "strain K12", "Drosophila melanogaster", "Caenorhabditis elegans", "Arabidopsis thaliana")
reviewed_venn = 1                 # 1 or 2
IMExdatabase = "IMEx"    # "X0469.IntAct." or "IMEx"
### ======================================================================== ###
# non-modifyable code
proteome_vs_interactome_summary.all$species.name = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", proteome_vs_interactome_summary.all$species.name)
proteome_vs_interactome_summary.all$species.name = gsub("strain K12", "Escherichia coli, strain K12", proteome_vs_interactome_summary.all$species.name)
SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", SPECIES_NAME)
SPECIES_NAME = gsub("strain K12", "Escherichia coli, strain K12", SPECIES_NAME)
library(dplyr)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, isoforms == TRUE)
proteome_vs_interactome_summary.all_isof = filter(proteome_vs_interactome_summary.all_isof, database == IMExdatabase)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all, reviewed == reviewed_venn)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, isoforms == FALSE)
proteome_vs_interactome_summary.all_noisof = filter(proteome_vs_interactome_summary.all_noisof, database == IMExdatabase)

library(VennDiagram)
{
grid.newpage()

if(reviewed_venn == 2){plotname = paste0("Proteome (SwissProt) coverage by interaction databases(",IMExdatabase,")")
databasename = "SwissProt"}
if(reviewed_venn == 1){plotname = paste0("Proteome (all UniprotKB) coverage by interaction databases(",IMExdatabase,")")
databasename = "UniprotKB"}

pushViewport(viewport(layout=grid.layout(nrow = length(SPECIES_NAME)+2, ncol=4, widths = unit(c(2/7,2/7,2/7,1/7), "npc"), 
                                         heights = unit(c(1/((length(SPECIES_NAME)+1)*4),1/((length(SPECIES_NAME)+1)*4),rep(1/(length(SPECIES_NAME)+1/2),length(SPECIES_NAME))), "npc"))))

pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("isoforms included", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("isoforms excluded", x = unit(0.5, "npc"),y= unit(0.5, "npc"))
popViewport()

for (i in 1:length(SPECIES_NAME)) {
  
  pushViewport(viewport(layout.pos.col=1, layout.pos.row = i+2))
  x =grid.text(SPECIES_NAME[i], x = unit(0.5, "npc"),y= unit(0.5, "npc"))
  popViewport()
  
  pushViewport(viewport(layout.pos.col=2, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_isof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
  
  pushViewport(viewport(layout.pos.col=3, layout.pos.row = i+2))
  source("double.venn.prot.R")
  venn = double.venn.prot(proteome_vs_interactome_summary.all_noisof[i,], scaled = FALSE, IMExdatabase = IMExdatabase)
  popViewport()
}
popViewport()
}
```


```{r Supplementary2_BioGRID_vs_IMEx_vs_Uniprot_N_Uniprot_Species, cache=F, fig.width=8, fig.height=8, fig.cap="Supplementary figure 2. The number of interacting proteins from given species or the other species in BioGRID" }
### combine the summaries for multiple species of how many interactors have non-uniprot identifiers
interactome_identifiers_summary.all = data.frame()
for (i in isoforms) {
  for(n in SPECIES_NAME) {
    filename.summary = paste("./summaries/","uniprotKB_IDs_and_",n,"_biogrid_from_mentha_interactors_summary", "_isoforms_",i,"_", date,".txt", sep = "")
    if(!file.exists(filename.summary)) {
      interactome_identifiers_summary.all
    }
    if(file.exists(filename.summary)) {
      interactome_identifiers_summary.o = as.data.frame(read.delim(filename.summary, stringsAsFactors = F))
      interactome_identifiers_summary.all = rbind(interactome_identifiers_summary.all, interactome_identifiers_summary.o)
    }
  }
}
interactome_identifiers_summary.all = unique(interactome_identifiers_summary.all)
## save all species summary
filename.summary.all = paste("./results/","interactome_identifiers_BioGRID_summary_",date,".txt", sep = "")
write.table(interactome_identifiers_summary.all, filename.summary.all, col.names=T,row.names=F,sep="\t",quote=F)

#################
interactome_identifiers_summary.all.s = interactome_identifiers_summary.all[,c(3,4,5,6,7)]
## Transform table for plotting with ggplot2
library(reshape2)
interactome_identifiers_summary.all.s.m= melt(data = interactome_identifiers_summary.all.s,
                                              id.vars = c("SPECIES_NAME", "SPECIES_ID"),
                                              variable.name = "decription",
                                              value.name = "number")
interactome_identifiers_summary.all.s.m=unique(interactome_identifiers_summary.all.s.m)
## rename yeast and E.coli
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain ATCC 204508", "S. cerevisiae, strain S288c", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("strain K12", "E. coli, strain K12", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Caenorhabditis elegans", "C. elegans", interactome_identifiers_summary.all.s.m$SPECIES_NAME)
interactome_identifiers_summary.all.s.m$SPECIES_NAME = gsub("Drosophila melanogaster", "D. melanogaster", interactome_identifiers_summary.all.s.m$SPECIES_NAME)

# filter out non-uniprot identifiers to make picture clearer
interactome_identifiers_summary.all.s.m$decription = gsub("\\.", " ", interactome_identifiers_summary.all.s.m$decription)
ind = interactome_identifiers_summary.all.s.m$decription != "interacting partners with the other identifier"
interactome_identifiers_summary.all.s.m = interactome_identifiers_summary.all.s.m[ind,]

# plot
library(ggplot2)
library(dplyr)

proteome_vs_interactome_plot <- ggplot(interactome_identifiers_summary.all.s.m, aes(x=SPECIES_NAME, y=number, fill=decription,label=number)) + geom_bar(width = 0.9, stat = "identity", position = "stack") + geom_label(position = "stack", size = 4, label.padding = unit(0.08, "lines")) +
  ggtitle("The number of interacting partners which have UniprotKB identifiers \n and belong to the species of interest") + theme(axis.text.x=element_text(angle = 20), axis.title.x = element_text(size = 0)) + ylab("number of proteins")
proteome_vs_interactome_plot
# save plot
# filename=paste("./results/", "interactome_identifiers_summary_plot_SMALL",date,".png", sep = "")
# ggsave(filename, proteome_vs_interactome_plot, width = 12, height = 12)

### ======================================================================== ###

```

```{r Supplementary3_protein_mass_distribution_qqplot, fig.width=8, fig.height=8, fig.cap="Supplementary figure 3. Proteomes have much more long proteins than normal distribution would predict (proteins, dots, are above the line in qqplot). The distribution of logarhithm base 10 of protein mass is approximately normal"}

SPECIES_NAME = "Homo sapiens"
n = SPECIES_NAME
## only reviewed = 2 is relevant for this analysis
reviewed = 2
r = reviewed
isoforms = FALSE
i = isoforms
      filename_vs_2 = paste("./analysis/","proteome_vs_interactome_protein_properties_f_", n,"_reviewed_",r,"_isoforms_",i,"_", date,".txt", sep = "")
      proteome_vs_imex_details_f = as.data.frame(read.delim(filename_vs_2, header = T, stringsAsFactors = F,quote=""))
      proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx = factor(proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx, ordered =F)
      proteome_vs_imex_details_f_minus_odor = proteome_vs_imex_details_f[-grep("Odor", 
                                                                                proteome_vs_imex_details_f$Protein.names),]
      proteome_vs_imex_details_f_minus_odor_olf = proteome_vs_imex_details_f_minus_odor[-grep("Olfactory",
                                                                                              proteome_vs_imex_details_f_minus_odor$Protein.names),]
      SwissProt_not_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_not_IMEX"]
      SwissProt_and_IMEX = proteome_vs_imex_details_f$Mass[proteome_vs_imex_details_f$whole_proteome_Uniprot_IMEx=="SwissProt_and_IMEX"]
                 ## is the distibution of mass or log(mass) normal?
      library(rafalib)
      mypar(2,2)
      popsd(log10(SwissProt_not_IMEX))
      median(log10(SwissProt_not_IMEX))
      mad(log10(SwissProt_not_IMEX))
      {
      qqnorm(log10(SwissProt_not_IMEX), main = "SwissProt_not_IMEX, log(protein mass)")
      qqline(log10(SwissProt_not_IMEX))
      qqnorm(log10(SwissProt_and_IMEX), main = "SwissProt_and_IMEX, log(protein mass)")
      qqline(log10(SwissProt_and_IMEX))
      qqnorm((SwissProt_not_IMEX), main = "SwissProt_not_IMEX, protein mass")
      qqline((SwissProt_not_IMEX))
      qqnorm((SwissProt_and_IMEX), main = "SwissProt_and_IMEX, protein mass")
      qqline((SwissProt_and_IMEX))
      }

            ## it indeed is
      
```

```{r Supplementary4_protein_mass_distribution_monte_carlo, fig.width=8, fig.height=8, fig.cap="Supplementary figure 4. Monte-Carlo sampling of can indentify the difference in protein mass between proteins present and missing from IntAct"}
                  ## Monte-Carlo simulation
            ## is there a significant difference in protein mass?
      # code can be used for things other than mass
      set.seed(1)
      # sample size
      Ns <- seq(5, 350, 20)
      lengthNs = length(Ns)
      # number of simulations
      B = 1000
      # function which takes samples and does Wilcox test
      simulation = function(n){  
       # x = cbind( matrix(sample(SwissProt_not_IMEX, B*n),B,n)
       # y = matrix(sample(SwissProt_and_IMEX, B*n),B,n)
       # genefilter::rowttests()
        wilcox.test.rr = matrix(0, 1, 3)
        x = sample(SwissProt_not_IMEX, n)
        y = sample(SwissProt_and_IMEX, n)
        wilcox.test.rr[1,c(1,2)] = wilcox.test(x, y, conf.int = T)$conf.int
        wilcox.test.rr[1,3] = wilcox.test(x, y, conf.int = T)$p.value
        return(wilcox.test.rr)
      }
      wilcox.test.rr = matrix(0, lengthNs, 3)
      # looping Monte-Carlo over samples sizes ]
     # for (n in 1:lengthNs) {
     #   z =replicate(B, simulation(Ns[n]), simplify = T)
     #   wilcox.test.rr[n,] = rowMeans(z)
     # }
      xx =cbind(wilcox.test.rr, Ns)
      qplot(xx[,4], xx[,3], ylab = "Wilcox test p-val", xlab = "proteins sampled, N", main = "this test doesn't make sense - \n why would we do bootstrap rather than \n just to measure how likely is that we get the result \n as extreme if we just sample two groups from general population \n which is exatly what permutation test does?")
```
      
```{r Supplementary4_protein_mass_distribution_permutations, fig.width=8, fig.height=8, fig.cap="Supplementary figure 4. Permutation of labels (does have interactions / doesn't have interactions) the difference in protein mass between proteins present and missing from IntAct"}
# permutations - wilcox test
proteome_vs_imex_details_f_shuffle = as.data.table(proteome_vs_imex_details_f[,c("Mass","whole_proteome_Uniprot_IMEx")])
proteome_vs_imex_details_f_shuffle[,Mass := log10(Mass)]
proteome_vs_imex_details_f_shuffle. = copy(proteome_vs_imex_details_f_shuffle)
set.seed(1)
wilcox.test.r10000 = replicate(10,{
proteome_vs_imex_details_f_shuffle.[,whole_proteome_Uniprot_IMEx := sample(whole_proteome_Uniprot_IMEx)]
      wilcox.test.r = wilcox.test(Mass~whole_proteome_Uniprot_IMEx,proteome_vs_imex_details_f_shuffle.)$statistic
},simplify = T)
# permutations - ttest
ttest.r10000 = replicate(10,{
proteome_vs_imex_details_f_shuffle.[,whole_proteome_Uniprot_IMEx := sample(whole_proteome_Uniprot_IMEx)]
      t.test.r = t.test(Mass~whole_proteome_Uniprot_IMEx,proteome_vs_imex_details_f_shuffle.)$statistic
},simplify = T)

           ## testing the difference in protein mass distributions
            ##of proteins absent/present in IMEx using Wilcox rank test
wilcox.test.r = wilcox.test(Mass~whole_proteome_Uniprot_IMEx,proteome_vs_imex_details_f)
ttest_r = t.test(Mass~whole_proteome_Uniprot_IMEx,proteome_vs_imex_details_f)
{
library(rafalib)
mypar(1,2)
hist(wilcox.test.r10000, xlim = c(min(wilcox.test.r10000),wilcox.test.r$statistic+wilcox.test.r$statistic/2))
abline(v = wilcox.test.r$statistic, col = "red")
hist(ttest.r10000, xlim = c(min(ttest.r10000),ttest_r$statistic+ttest_r$statistic/2))
abline(v = ttest_r$statistic, col = "red")
}
```


```{r poster_figures, fig.height=8, fig.width=12}
multiplot(plotlist=list(protein_mass + theme(legend.position = "none") + theme(plot.margin = unit(c(0, 0.5, 0.5, 0.5), "cm")), 
                        protein_publ + theme(legend.position = "none") + theme(plot.margin = unit(c(0, 0.5, 0, 0.5), "cm")), 
                        protein_charge + theme(legend.position = "none") + theme(plot.margin = unit(c(0, 0.5, 0.5, 0.5), "cm")), 
                        protein_hydropathy + theme(legend.position = "none") + theme(plot.margin = unit(c(0, 0.5, 0, 0.5), "cm"))), cols = 2)
```