---
title: "enrichGO() for a protein list mapped to GO terms using Bioconductor package \"org.Hs.eg.db\" "
author: "Vitalii Kleshchevnikov"
date: "23 February 2017"
output: html_document
---

clusterProfiler vignette - https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html

   Here, I take swissprot as a reference(universe) set, then I generate an “experimental" list of proteins enriched for 3 specific GO terms (leucocyte stuff) by taking proteins associated with those terms and mixing them with random proteins. Then I do enrichment and discover my leucocyte sets. Then I try the same procedure with the “experimental” set consisting just of random proteins.

### You can test if your specific set of proteins (1) is enriched in any of the protein sets associated with GO terms compared to the other big set (which includes set 1)
## Using enrichGO() function
```{r setup}
suppressPackageStartupMessages({
      library(clusterProfiler)
      library(data.table)
      library(org.Hs.eg.db)
      library(qvalue)
      library(ggplot2)
      })
```

**Below you can see when the information included in the "org.Hs.eg.db" package was downloaded as well as which identifiers can be mapped and what information you can get using this package.** For, example, Gene Ontology is updated biannually and the last update was on 2016-Sep26.

```{r org.Hs.eg.db_summary}
org.Hs.eg.db
keytypes(org.Hs.eg.db)
```

**Downloading protein universe (all human proteins in Swissprot):**

```{r universe}
swiss_prot = fread("http://www.uniprot.org/uniprot/?query=reviewed:yes+AND+organism:9606&columns=id&format=tab", colClasses = "character")
```

**Downloading my "experimental" protein set which is enriched for proteins assiciated with specific GO terms ("GO:0001909", "GO:0045321", "GO:0002757")**

```{r experimental_list}
GO_leuc_cytotox = fread("http://www.uniprot.org/uniprot/?query=reviewed:yes+AND+organism:9606+AND+GO:0001909&columns=id&format=tab", colClasses = "character")
GO_leucocyte_activ = fread("http://www.uniprot.org/uniprot/?query=reviewed:yes+AND+organism:9606+AND+GO:0045321&columns=id&format=tab", colClasses = "character")
GO_immune_response_activ_signal_transd = fread("http://www.uniprot.org/uniprot/?query=reviewed:yes+AND+organism:9606+AND+GO:0002757&columns=id&format=tab", colClasses = "character")

# taking random sample of proteins assosicated with these terms
set.seed(1)
my_protein_set = unique(c(sample(swiss_prot$Entry, 1000),
                          sample(GO_leuc_cytotox$Entry),
                          sample(GO_leucocyte_activ$Entry, length(GO_leucocyte_activ$Entry)/10),
                          sample(GO_immune_response_activ_signal_transd$Entry, length(GO_immune_response_activ_signal_transd$Entry)/10)
                          ))
my_protein_set = my_protein_set[!is.na(my_protein_set)]
summary(my_protein_set)
```

**Testing if any protein sets (all GO terms) are enriched. Using Benjamini and Hochberg multiple hypothesis testing correction** 
Arguments:  
- universe = swiss_prot - reference set of proteins   
- gene = my_protein_set - set of proteins we study  
- keytype = "UNIPROT" - type of identifier  
- ont = "BP" - Gene Ontology: BP, MF, CC  
- pvalueCutoff = 0.05, qvalueCutoff = 0.2 - P-values and adjusted p-values were filtered out by the threshold giving by parameter pvalueCutoff. However, I don't how exactly they have calculated adjusted p-values, and why qvalue and adjusted p-values are different. I suspect adjusted p-value is given by p.adjust(vector, method = "BH"), but I don't know how they calculate q-values.  
- minGSSize = 10 - only terms describing more than minGSSize proteins will be considered  
- maxGSSize = 500 - only terms describing less than maxGSSize proteins will be considered - filter out very general terms  
- pAdjustMethod = "BH" - Benjamini and Hochberg multiple hypothesis testing correction, returns qvalue column  
- readable = FALSE - use gene names (if TRUE) instead of EntrezIDs when returning the result  

```{r enrichment}
# ENTREZID = select(org.Hs.eg.db, keys = my_protein_set, keytype = "UNIPROT", columns = "ENTREZID")
ego <-  enrichGO(gene = my_protein_set, org.Hs.eg.db, keytype = "UNIPROT", ont = "BP",
  pvalueCutoff = 0.05, pAdjustMethod = "BH", universe = swiss_prot$Entry, qvalueCutoff = 0.2,
  minGSSize = 10, maxGSSize = 500, readable = FALSE)
ego
ego_sorted = as.data.frame(ego)[order(as.data.frame(ego)$p.adjust),]
```

GO terms which "experimental" protein list should be enriched for: **"GO:0001909" - leukocyte mediated cytotoxicity, "GO:0045321" - leukocyte activation, "GO:0002757" - immune response-activating signal transduction**  

**top 10 terms as discovered by enrichment analysis**  
`r paste0(ego_sorted$Description[1:10],"\n")`


**Generating my "experimental" protein list in which no proteins are enriched**

```{r experimental_list_rand}
my_protein_set_rand = unique(sample(swiss_prot$Entry, 1000))
my_protein_set_rand = my_protein_set_rand[!is.na(my_protein_set_rand)]
summary(my_protein_set_rand)
```

**Testing if protein sets are enriched in my random protein list**

```{r no_enrichment}
ego2 <-  enrichGO(gene = my_protein_set_rand, org.Hs.eg.db, keytype = "UNIPROT", ont = "BP",
  pvalueCutoff = 0.05, pAdjustMethod = "BH", universe = swiss_prot$Entry, qvalueCutoff = 0.2,
  minGSSize = 10, maxGSSize = 500, readable = FALSE)
ego2
# as.data.frame(enriched_terms) # this is how you can extract info
```


### adjusted P value and q value  

-  pvalueCutoff = 0.05, qvalueCutoff = 0.2 - P-values and adjusted p-values were filtered out by the threshold giving by parameter pvalueCutoff. However, I don't how exactly they have calculated adjusted p-values, and why qvalue and adjusted p-values are different. I suspect adjusted p-value is given by p.adjust(vector, method = "BH"), but I don't know how they calculate q-values.   
- here I try to answer this question   

```{r p_and_q}
ego_p_and_q <-  enrichGO(gene = my_protein_set, org.Hs.eg.db, keytype = "UNIPROT", ont = "BP",
  pvalueCutoff = 1, pAdjustMethod = "BH", universe = swiss_prot$Entry, qvalueCutoff = 1,
  minGSSize = 10, maxGSSize = 500, readable = FALSE)
ego_sorted_p_and_q = as.data.frame(ego_p_and_q)[order(as.data.frame(ego_p_and_q)$p.adjust),]

qplot(x = ego_sorted_p_and_q$pvalue, main = "histogram of p-values", geom = "histogram")

p.adjust_p_and_q = p.adjust(ego_sorted_p_and_q$pvalue, method = "BH")
qvalue_p_and_q = qvalue(ego_sorted_p_and_q$pvalue)
p.adjust.res = all.equal(ego_sorted_p_and_q$p.adjust, p.adjust_p_and_q)
qvalue.res = all.equal(ego_sorted_p_and_q$qvalue, qvalue_p_and_q$qvalues)
qvalue.res_2 = sapply(seq(1.96, 2.05, length.out = 1000), function(i){
as.numeric(c(gsub("Mean relative difference: ","",all.equal(ego_sorted_p_and_q$qvalue,qvalue_p_and_q$qvalues*i)),i))
})
best_match =t(qvalue.res_2)[which.min(t(qvalue.res_2)[,1]),2]
```

`r nrow(ego_sorted_p_and_q)` GO terms fit min and max criteria.  
are adjusted p-values really calculated using p.adjust(vector, method = "BH")?   
`r p.adjust.res`   
are adjusted q-values calculated using qvalue(vector)?   
`r qvalue.res`  
are adjusted q-values calculated using qvalue(vector)*`r best_match`?   
`r all.equal(ego_sorted_p_and_q$qvalue,qvalue_p_and_q$qvalues*best_match)`  

This suggests that the authors of the package decided to multiply qvalue calculated by qvalue function by 2 

Going for more explanations on the methods to http://bioconductor.org/packages/release/bioc/vignettes/DOSE/inst/doc/enrichmentAnalysis.html 
That page says "P-values were adjusted for multiple comparison, and q-values were also calculated for FDR control."

In my understanding, adjusting p-values for multiple comparison using Benjamini and Hochberg procedure is a way to control FDR. Using qvalues is an alternative and a less conservative method.
http://genomicsclass.github.io/book/pages/multiple_testing.html

In the end, I can either use adjusted p-value as provided by enrichGO() or recalculate qvalue